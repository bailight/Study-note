# Базис булевых компьютеров

Все перечисленные выше компьютеры имеют не только разные принципы функционирования (от механики до электричества), но также обладают принципиально разной внутренней организацией, в частности:

- аналоговое или цифровое представление данных;
- разные системы счисления;
- разные принципы распространения информации;
- последовательность операций и что рассматривается как операция.

В этом разделе мы зафиксируем то, что можно отнести к условному базису булевых компьютеров (данное понятие не является широко распространённым и восходит к Джорджу Булю, основателю булевой логики) и принципам их функционирования.

С математической точки зрения булевый компьютер --- это компьютер, который:

- реализует булеву логику, а именно:
    - механизм представления логических значений;
    - функционально полный набор логических операций, позволяющий реализовать И, ИЛИ, НЕ;
- имеет набор триггеров, которые позволяют сохранять состояние, примечания:
    - они реализуемы в рамках чистой булевой логики, но, как правило, целесообразнее зафиксировать их как базовый элемент;
    - далее мы будем говорить в основном о D-триггерах, которые позволяют зафиксировать входной сигнал в требуемом состоянии.


Сейчас мы фокусируемся на цифровой схемотехнике и логике. 在此之前我们了解一下谢多夫分层系统发展原理与元系统跃迁，两个概念共同构成了对系统发展和演变的特定解释框架。

**谢多夫等级制度的发展原则**

谢多夫等级制度的发展原则的核心关键在于 “限制较低层次的多样性以获得更高层次的多样性”。其目的是为了更好地整合资源、提高效率，实现更高层次的多样性创造条件，提升系统整体性能和适应性。

如果我们要制作高效编译器，我们需要固定标准化数量的处理器，这样可以限制处理器在数量和类型上的低层次多样性。如此我们便能将研发资源集中投入到编译器与这些标准化处理器的适配与优化中，提高编译效率。

在操作系统领域，当前市面上主流的苹果和安卓两大系统，一定程度上限制了操作系统层面的低层次多样性。这种限制促使开发者聚焦于这两大平台进行应用开发，虽然减少了操作系统种类的多样性，但却在应用层面实现了丰富的多样性，满足了用户多样化的需求。而若出现新系统，为其开发与苹果、安卓上相同功能的应用，由于缺乏统一的开发基础和生态积累，开发成本会极为高昂，难以在短期内实现应用的丰富多样。

从技术发展现状来看，处理器从架构角度数量并不繁多，编程语言的出现也逐渐减少，这也反映了通过限制低层次多样性来推动更高层次的发展。例如，有限的处理器架构类型使得软件开发者能够更精准地优化程序，在软件功能、兼容性等更高层次实现多样性；编程语言数量的精简，促使开发者更深入地挖掘语言特性，创造出更复杂、多样的软件应用。

**元系统转变**

元系统转变是瓦伦丁・图尔钦(Valentin Turchin)提出的概念，它描述了系统向新组织层次过渡并成为元系统的过程，即几个系统整合为一个具有新特性的更复杂系统。最好的例子如生命起源，单细胞到多细胞的进化。将一些本来互相独立的组件，如分子，细胞，个体等等的组合，突现出的系统调整和控制其间的互动。而在编程领域，这种元转变的发生则十分迅速。基于此，我们需要在新概念体系的基础上建立新的计算系统，并且该系统可以遵循不同的原则。

![_Уровни в электронных компьютерах, Харрис и Харрис_](fig/level-of-abstraction-for-computing-system.png){#fig:level-of-abstraction-for-computing-system}
<!-- for reference: [figure](#fig:level-of-abstraction-for-computing-system) -->

从应用层到物理层：
- Application Software（应用软件）：直接面向用户，满足各种具体应用需求，像办公软件、游戏等。

- Operating systems（操作系统）：管理计算机硬件与软件资源，为应用软件提供运行环境，比如 Windows、Linux 。

- Architecture（架构）：涉及计算机系统设计，包括指令集、存储结构等，决定计算机性能和功能 。

- Micro - architecture（微架构）：对计算机架构的细化，关注处理器内部具体电路、逻辑单元等设计 。

- Logic（逻辑层）：利用逻辑门等构建电路，实现基本逻辑运算，是硬件实现的逻辑基础 。

- Circuit systems（电路系统）：由各类电子元件组成电路，实现逻辑功能，传输和处理电信号 。

- Electronic devices（电子器件）：如晶体管、二极管等基础电子元件，是构建电路的基础 。

- Physical（物理层）：基于物理原理，研究电子在半导体等材料中的行为等，是计算机硬件的物理基础。

而在逻辑层上面的东西才是我们感兴趣的东西。

## Кодирование информации

### 整套布尔函数：
布尔函数是一类特殊函数，通过它能够写出任何逻辑函数，进而构建任意的计算系统。全套布尔函数包含“与”“或”“非” 这几种基本运算。此外，还有两个特殊的逻辑运算：
- 与非（谢弗行程）：表示为 \(x|y = \overline{xy}\) ，即先对 \(x\) 和 \(y\) 进行“与”运算，再取反。
- 或非（刺穿箭头）：表示为 \(x\downarrow y=\overline{x\vee y}\) ，即先对 \(x\) 和 \(y\) 进行“或”运算，再取反 。这两种特殊运算（与非、或非）也都可以用来写出任意逻辑函数。

**基础与构建关系**
“与” “或” “非”是最基础的布尔运算，是构建其他复杂逻辑函数的基石。任何复杂的逻辑关系都可以通过有限次地组合这三种基本运算来描述。

**等价替代关系**
“与非”和“或非”这两种运算虽然不是最基础的布尔运算，但它们具有通用性，单独使用其中任何一个（即仅通过“与非”运算，或者仅通过“或非”运算 ），就可以等价地实现“与”“或”“非”这三种基本运算所能构建出的任意逻辑函数。也就是说，在构建逻辑函数和计算系统的功能上，“与非”“或非”和“与”“或”“非”基本运算集合是等价的，可以相互替代来达成相同的逻辑表达和计算系统构建目标。 

### Двоичное представление чисел

二进制逻辑的诞生源于解决模拟系统存在的问题。在模拟系统中，数值范围太大会引发很多问题。

*模拟系统是一种通过对实际物理现象或过程进行模拟，利用物理量的连续变化来表示和处理信息的系统。在模拟电路中，电压或电流的连续变化可以用来表示声音、图像、文字等信号。*

- 级联系统中，每个阶段的转换器只要存在微小误差，经过多环节传递后，在末端转换器处就会引发信号转换的复杂偏差，导致结果难以预测。
- 电线传输过程中极易受到电磁干扰等因素影响，造成信号扭曲变形。
- 温度、湿度、材料质量等众多环境变量都会对模拟系统产生影响，导致系统工作结果不稳定、数据准确性差。

![_Logic levels and noise margins_](fig/logic-levels-and-noise-margins.png){#fig:logic-levels-and-noise-margins}
<!-- for reference: [figure](#fig:logic-levels-and-noise-margins) --> 

**Driver**（驱动端）--- 负责产生并输出信号，是信号的源头。
**Receiver**（接收端）--- 接收来自驱动端的信号，并进行处理，判断输入信号属于逻辑高电平还是逻辑低电平。
**Noise Margin High**（高电平噪声容限， \(NM\) ） --- 参数，表示在不影响接收端正确识别逻辑高或者低电平的前提下，信号在传输过程中所能容忍的最大噪声干扰幅度。
- 高电平：\(NM_H = V_{OH(min)} - V_{IH(min)}\)
- 低电平：\(NM_L = V_{IL(max)} - V_{OL(max)}\)
**Forbidden Zone** --- 位于逻辑高电平和逻辑低电平输入范围之间的区域，这个区域内的电压值，接收端无法明确判定是逻辑高电平还是逻辑低电平，会导致逻辑判断错误，所以要尽量避免信号电压落入该区域。

二进制编码采用离散化的信息表示方式，从根本上改善了这些问题：
- 通过划定明确的电压区间，将信号抽象为逻辑 0 和逻辑 1。即使代表逻辑 0 的电流出现一定波动，只要不超出对应区间，就不会影响最终的逻辑判断。例如，在 TTL（晶体管 - 晶体管逻辑）电路中，规定低于 0.8V 为逻辑 0，高于 2V 为逻辑 1 ，处于 0.8 - 2V 之间的区域就是禁区（forbidden zone）。实际的电流信号会落在噪声容限（Noise Margin，NM）区间内，这一区间保证了信号在存在一定干扰的情况下，仍能被准确识别。
- 二进制算术相较于十进制，从硬件实现角度更为简便。二进制仅需处理 0 和 1 两种状态，基本算术运算（如加法、减法）可通过简单的逻辑门电路（与门、或门、非门等）实现。而十进制需要设计更复杂的电路来处理 0 - 9 十种状态。
- 通过增加二进制数的位数（即位宽），可以线性扩展数值表示的范围和精度。例如，8 位二进制数能表示的无符号整数范围是 0 - 255，而 16 位二进制数则可扩展至 0 - 65535 。又在表示小数时，也可以通过固定小数点位置（定点数）或采用科学计数法形式（浮点数），利用增加位数来提升精度，这种通过位宽扩展实现的数值表达能力提升，是二进制系统的重要特性。
- 二进制系统的误差是 “设计决定”（by design），而非 “实现导致”（by implementation）。这意味着，只要计算机硬件遵循相同的二进制设计标准，在相同的输入条件下，不同计算机（只要功能正常）将产生相同的计算结果。这种确定性使得二进制系统在数据处理和程序运行上具有高度一致性，极大方便了软件开发、系统调试和数据交互，避免了因硬件实现差异（温度等众多环境变量）导致的计算结果不一致问题。

Недостатки:

- Нечеловеческое представление ("а и не надо", бинарные часы，其显示形式与人类习惯的时间读取方式差异明显，需要专门学习和转换才能理解).
- Простые десятичные числа записываются в виде бесконечных двоичных дробей. 十进制的 0.1转换为二进制后是无限循环小数。这不仅在存储和计算时需要特殊处理，容易产生精度损失。尤其在对数据准确性要求极高的银行系统中，货币计算必须保证分毫不差，不能出现金额丢失或凭空增加的情况。因此，银行系统通常直接对整数进行计算，例如将金额以 “分” 为单位表示成整数，从而规避因二进制小数精度问题可能引发的计算误差。
- Дискретное кодирование сигнала (точность) 需要将连续模拟信号通过采样和量化转换为数字信号。量化时，由于只能将信号映射到有限个离散值，因此必然产生误差。一旦数字电路输出结果，其精度便被固定，即便结果与真实值接近，也无法进一步提升精度。

![Аналоговый и цифровой сигнал](image.png)
{#fig:Аналоговый и цифровой сигнал}

На самом деле, работа с бинарной логикой на практике часто требует работы с тремя, а то и четырьмя состояниями (использован синтаксис языка описания аппаратуры Verilog):

- `0` и `1`;
- `z` --- 高阻态，表示断开或悬空状态，即数据源（导线）未连接有效信号，不存储逻辑 0 或 1 的数值。在实际电路中，这种状态常用于总线架构设计，当多个设备连接到同一条总线上时，未被选中的设备可以将自身输出设置为高阻态，避免对总线信号产生干扰，从而实现多个设备对总线资源的分时复用。这也是实际应用中常出现用两个正物理电平对二进制状态进行编码的原因之一。
- `x` --- 未知态，代表不确定或任意值。在电路实现中，当出现如除法器除以 0 这类无定义操作时，其输出数据便处于未知态；另外，在数字电路的锁存器之间发生同步错误时，也可能捕获到错误的、无法确定的数值，此时该信号状态即为 x。

<!-- TODO: добавить отступление по конкретным форматам представления чисел (двоично-десятичное представление (точность расчетов в десятичной системе у дробей, простота вывода для пользователя), фиксированная точка, дополнительный код, плавающая точка), бинарной арифметике и её реализации через бинарную логику. -->

#### Формат представления чисел

Машинное слово --- некоторое совокупность бит единичков и ноликов(единица данных), естественная для обработки вычислителем.

“自然处理” 意味着计算机的运算器、控制器等核心部件在设计上能够直接对该长度的数据进行高效处理，无需进行额外的复杂转换或拆分操作。在 32 位计算机系统中，机器字长通常为 32 位，即一次可以处理 32 个 0 或 1 组成的数据；而在 64 位计算机中，机器字长为 64 位，数据处理能力得到显著提升。

*Структура*
1. 位（bit）：机器字的基本组成元素是二进制位，每一位只能表示 0 或 1 两种状态。多个位按照一定顺序组合在一起，形成具有特定意义的机器字。
2. 字长：指机器字中包含的二进制位的数量，它是机器字最重要的属性之一。常见的字长有 8 位、16 位、32 位和 64 位。字长决定了计算机一次能够处理的数据量和精度。例如，8 位字长的计算机一次最多能处理 2^8（即 256）种不同的状态组合，而 64 位字长的计算机则可以处理 2^64 种状态组合，能够表示更大范围的数值和更丰富的信息。字长是计算机体系结构设计的关键参数之一，它影响着计算机的硬件组成、指令集设计以及软件的兼容性。
3. 数据类型表示：不同的位组合可以用来表示各种数据类型，如整数、浮点数、字符等。对于整数类型，一部分位用于表示符号（通常最高位为符号位，0 表示正数，1 表示负数），其余位用于表示数值大小；对于浮点数，则需要通过特定的格式。

*функция*
1. 计算机的内存以机器字为单位进行编址和存储数据。当程序需要存储或读取数据时，通常以机器字为基本单元进行操作。在向内存写入一个整数时，会将该整数按照机器字的格式存储在相应的内存地址中。
2. 运算器在执行算术运算（如加法、减法、乘法、除法）和逻辑运算（如与、或、非、异或）时，直接以机器字为操作对象。例如，在进行两个整数相加时，计算机将两个整数以机器字的形式读入运算器，按照二进制算术规则进行计算，并将结果以机器字的形式输出。
3. 计算机指令也以机器字的形式存储和传输。指令中包含了操作码（指示计算机执行何种操作，如加法、跳转等）和操作数（指令操作的对象）等信息。处理器从内存中读取指令机器字，解析操作码和操作数，然后执行相应的操作。

**Позиционные системы счисления**

在进位计数制中，数字的位置决定了它所代表的数值大小，每个数位都有其对应的权值，不同数位上的数字根据其位置乘以相应的权值后相加，就得到了该数字所表示的实际数值。常见的进位计数制有十进制、二进制、八进制、十六进制等。

**Обратный код**

反码是一种用于表示有符号整数的编码方式，其定义为将原数按位取反，得到的数称为原数的反码。
反码的计算方式：
正数的反码就是其本身，负数的反码是在原码的基础上，符号位不变，其他按位取反再加一（也就是直接将原数的每一位进行取反操作）。例如，原数 101101 的反码为 010010。
在数字电路中，反码的一个重要作用是在运算过程中进行符号位的判断。
不过，反码在运算方面存在一定局限性，例如 “0” 有两种表示形式（+0 的反码是 00000000，-0 的反码是 11111111），这使得运算规则相对复杂，实际应用中逐渐被补码取代。

**дополнительный код**

补码是一种更为通用的有符号整数编码方式，通过将原数的反码加上 1 得到原数的补码。
计算方法：正数的补码就是其本身，负数的补码是先得到反码，再将反码加 1。如原数 101101，反码为 010010，补码则为 010011。
补码在数字电路中的作用非常广泛，可实现基本的整数加减运算，通过将减法转换为加法（减去一个数等于加上这个数的补码），简化了运算电路的设计。并且可以避免出现逆运算的情况。同时，补码解决了 “0” 的唯一表示问题（0 的补码只有 00000000 一种形式），还能扩展数值表示范围（如 8 位二进制补码可表示 -128 到 + 127，比原码和反码多表示一个负数），提升了计算机运算的效率和准确性。

**Код смещения**

偏移码是一种用来表示有符号数的编码方式，它是将原来的数值与一个偏移值相加来进行表示，通常偏移值是$2^{n-1}$（n为编码位数）。
偏移码的计算方式：
将原数值与设定的偏移值直接相加。
偏移码在数字电路中的应用比较有限，但它可以用来进行特定的计算：在浮点数的 IEEE 754 标准中用于表示指数部分；在计算移位操作时可以使用偏移码来进行计算。

**Big & Little endian**
![Big & Little endian](image-2.png)
{#fig:Big & Little endian}
大端序（Big endian）：也叫大端模式或大字节序，是一种数据存储方式。在这种模式下，数据的高位字节存于低地址，低位字节存于高地址。例如，对于 32 位整数0x12345678，在大端序中，0x12存于内存低地址，接着依次是0x34、0x56、0x78存于更高地址，就像按从左到右（高位在前）的顺序存储。常用于网络协议、一些文件格式等，符合人类正常的思维习惯，先看到数据高位部分。许多文件格式在存储数据时采用大端序，方便不同系统的程序按统一方式读取和解析文件内容。
小端序（Little endian）：也称小端模式或小字节序。与大端序相反，数据的低位字节存于低地址，高位字节存于高地址。对于0x12345678，在小端序中，0x78存于内存低地址，接着是0x56、0x34、0x12存于更高地址，如同从右到左（低位在前）存储。在硬件实现上可能更简单，因为 CPU 按字节读取内存时从小地址开始，先读取到数据低位部分，无需额外转换操作。部分数据库系统选择小端序存储数据，能更高效地利用存储空间和进行数据检索，尤其在处理大量二进制数据时优势明显。还可以用于一些微处理器和微控制器。
![Big & Little endian in memory](image-3.png)
{#fig:Big & Little endian in memory}

由于不同系统或应用可能采用不同字节序，所以在不同字节序环境间传输或处理数据时，我们可能需要进行字节序转换。

**фиксированная точка**

фиксированная точка 是小数点位置固定的数。在计算机中，通常约定小数点在某一固定位置，如整数部分和小数部分之间。定点数不像浮点数那样可以通过指数部分来调整小数点的位置，而是在数据表示时就约定好小数点的位置，并且在整个运算过程中保持不变。与浮点数相比，占用的存储空间和硬件资源较少。
表示范围和精度由设定的位数决定。位数越多，能表示的数值范围越大、精度越高。但位数有限时，范围和精度不能兼顾。如 8 位定点整数表示范围是 - 128 到 127。在对计算速度要求高、数值范围可预估的场景常用。如嵌入式系统控制、简单信号处理等，因其计算简单，可快速得出结果。

- 加法和减法：与普通的整数或小数运算类似，只要保证参与运算的数的小数点位置相同，就可以直接进行加减运算。例如，两个 16 位定点数，都约定前 8 位为整数部分，后 8 位为小数部分，它们的加法运算就是对应位相加，注意进位即可。
- 乘法：两个定点数相乘，结果的位数会增加。需要根据事先约定的小数点位置来确定乘积的小数点位置。例如，两个 8 位纯小数相乘，结果可能是 16 位的数，要按照规则确定最终结果中小数点的位置。
- 除法：除法运算可能会导致结果的精度损失，因为可能除不尽。在进行定点数除法时，需要考虑商的表示范围和精度问题。

**плавающая точка**

浮点数是一种在计算机中用于表示实数的数值表示方法，其特点是小数点的位置可以浮动，通过指数部分来调整数值的大小范围，从而能够表示非常大或非常小的数。

通常由三个部分组成：
符号位（Sign Bit）：占 1 位，用于表示数值的正负，0 表示正数，1 表示负数。
指数位（Exponent Bit）：若干位（如在单精度浮点数中占 8 位），表示 2 的幂次方，用于调整数值的大小范围。指数位通常采用偏移码表示，以便能够表示正负指数。
尾数位（Mantissa Bit）：若干位（如在单精度浮点数中占 23 位），表示数值的有效数字部分。

![плавающая точка](image-1.png)
{#fig:плавающая точка}

通过指数位的变化，浮点数可以表示极大或极小的数。例如，单精度浮点数可以表示的数值范围大约是 \(\pm 1.175494351 \times 10^{-38}\) 到 \(\pm 3.402823466 \times 10^{38}\)。
尾数位的位数决定了浮点数的精度。尾数位越多，能够表示的有效数字就越多，精度也就越高。但由于位数有限，浮点数在表示某些数值时可能会存在舍入误差，例如十进制的 0.1 转换为二进制浮点数时就无法精确表示。

**Тегированные данные**
标记数据指的是那些带有额外标识信息（即 “标记”）的数据。这些标记用于描述数据的属性、类型、来源、用途等相关信息，使数据不仅仅是单纯的数值或字符集合，而是包含了更多元化的语义信息。例如，在一个包含人员信息的数据库中，对于年龄这一数据，可能会附上 “年龄” 这样的标记，表明该数据代表的是一个人的年龄；或者在图像数据中，标记可以用来表示图像的分辨率、色彩模式、拍摄设备等信息。
通过添加标记，数据具有了更明确的语义。这有助于计算机系统和人类用户更准确地理解数据的含义，减少对数据解释的歧义。并且标记为数据的分类、检索、过滤等操作提供了便利。在大规模数据存储和处理系统中，通过对标记的操作，可以快速找到符合特定条件的数据。

**двоично-десятичное представление**

在计算机系统及数据处理过程中，我们会使用二进制与十进制两种数制之间的转换，因为计算机内部以二进制存储和处理数据，而人类习惯使用十进制进行读写。

*BCD*
BCD 码本质是一种有理数编码方案，它并非将整个十进制数整体转换为二进制，而是针对十进制数的每一个数位，分别用四位二进制代码进行表示。
在进行算术运算时，规则比普通二进制运算复杂。以加法为例，当两个 BCD 码相加结果大于 9 时，需进行特殊修正操作，一般是加 6 来完成进位调整。原因在于 BCD 码仅使用 4 位二进制数中 0000 至 1001 这 10 种组合，普通二进制加法产生的 1010 至 1111 组合在 BCD 码体系中无定义。
不过与直接用二进制表示相同数值相比，BCD 码通常占用更多存储空间。例如十进制数 15 ，二进制表示为  1111 ，仅需 4 位；而BCD 码表示为 0001 0101 ，占用 8 位。

- точность расчетов в десятичной системе у дробей
  在十进制系统中，部分小数在转换为二进制时会出现精度问题。例如，十进制数 0.1 无法精确转换为二进制，其二进制表示为 0.0001100110011…，是无限循环小数。在实际计算中，若截断二进制小数以满足存储或运算需求，就会产生精度损失。为确保计算结果准确，在涉及二进制 - 十进制转换的计算时，需根据具体场景设置合适的精度阈值，并采用相应的舍入规则（如四舍五入、向零舍入等）。
- простота вывода для пользователя
  保留了十进制数的位权概念和数字形式，每 4 位二进制对应一个十进制数位，便于快速转换回十进制进行查看与分析，符合人类的认知习惯，可读性强。

**Код Грея**
二进制数值编码系统，其重要特性是任意两个相邻的代码组合之间仅有一个二进制位不同。也就是说，在格雷码序列中，当从一个数值转换到下一个数值时，只有一位二进制数会发生变化。例如，常见的 4 位格雷码序列部分为：0000、0001、0011、0010、0110、0111、0101、0100 等，相邻的两个码组之间都严格遵循仅有一位不同的规则。
- 由于相邻码组仅一位不同，这使得在数据传输或状态转换过程中，减少了因多位同时变化可能产生的错误。例如，在一些数字电路中，当信号从一个状态转换到相邻状态时，如果使用普通二进制码，可能会出现多位同时跳变，容易受到干扰而产生错误；而使用格雷码，只有一位变化，大大降低了出错的概率。
- 格雷码具有循环特性，即第一个码组和最后一个码组也仅一位不同，形成一个闭环。这种特性在一些需要循环计数或状态循环转换的应用中非常有用，如环形计数器等。、
- 格雷码的生成具有反射规律。以 3 位格雷码为例，先写出 2 位格雷码（00、01、11、10），然后将其反射（10、11、01、00），在反射部分的前面加上 1，原部分前面加上 0，就得到了 3 位格雷码（000、001、011、010、110、111、101、100）
在数据传输过程中，格雷码可以用于减少误码率。当信号在传输过程中受到干扰时，由于格雷码相邻码组仅一位不同，即使发生一位错误，也只会导致数值的微小变化，而不像普通二进制码那样可能产生较大的数值偏差。


**Base64**
Base64 --- 一种将二进制数据转换为文本格式的编码方式 。它的原理是把数据按每三个字节一组进行划分，生成四个 6 位的二进制序列，每个序列对应一个 Base64 字符。编码字符集包含 26 个大写拉丁字母（A-Z）、26 个小写拉丁字母（a-z）、10 个数字（0-9）以及 2 个额外字符（通常是 “+” 和 “/”）。当数据的字节数不是 3 的倍数时，会使用 “=” 作为填充字符。在计算机系统中，数据通常以二进制形式存储和传输，但在某些情况下，需要将二进制数据转换为文本形式。经常用于电子邮件，网页（减少对外部资源的请求），HTTP传输用户凭据。
但这个编码也有属于自己的缺点：
- Base64 编码会使数据量增加约 33%。这是因为原本每 3 个字节的数据会被编码为 4 个 Base64 字符，例如，对于一段 300 字节的数据，编码后大约会变成 400 个字符。
- 虽然Base64编码后的内容看起来难以直接理解，但通过简单的解码操作就可以还原出原始数据，不能提供真正的安全保护。
- 在涉及资金交易等关键业务系统中，对数据（如交易指令、钱包地址等信息）进行 Base64 编码时出现错误，比如编码过程中数据丢失、乱码，或者解码时出现错误，可能导致系统误读数据，进而引发错误的交易操作，造成资金损失。
- 在一些区块链或加密货币相关应用中，会使用 Base64 编码传输数据，并配合自动签名机制确认交易。若 Base64 编码的数据被恶意篡改，而签名验证环节存在漏洞，未能正确识别数据已被修改，就可能导致未经授权的交易被执行，造成资金损失。

**Base58**
Base58 --- Base64 的扩展。它对字符集进行了修改，特意避开了一些在打印时容易产生歧义的字符，如数字 “0”、大写字母 “O”、大写字母 “I”、小写字母 “l” 以及一些特殊字符（“+” 和 “/”）。Base58 的字符集由 58 个字符组成，主要包含数字和字母，这使得编码后的字符串在人工识别和输入时更准确。
Base58 的字符集有 58 个独特字符 ，不包含数字 “0”、字母大写 “O”、字母大写 “I”、字母小写 “l” ，以及 “+” 和 “/” 符号。
它的缺点：
- Base58 不像 Base64 那样有广泛接受的标准规范，在不同的应用场景或系统中，可能存在字符集定义或编码实现方式的差异。这就导致在跨系统或跨平台使用时，可能会出现兼容性问题，增加了开发和维护的复杂性。
- 和 Base64 一样，不具备加密功能。它只是对数据进行了一种转换，将二进制数据转换为可打印的字符形式，通过简单的逆操作就可以还原出原始数据，不能对敏感信息提供有效的保护。
- 而且Base58 编码也会使数据量有所增加。因为它是用 58 个字符来表示数据，相比直接使用二进制表示，需要更多的字符来存储相同的数据内容。其字符长度会比原数据长。


#### Бинарной арифметике и её реализации через бинарную логику

二进制算术是一种基于二进制数系统的算术运算体系，它只使用两个数字 0 和 1 来表示数值，并遵循特定的运算规则进行计算。
二进制转十进制：按位权展开求和，如1101的十进制值为\(1\times2^3 + 1\times2^2 + 0\times2^1 + 1\times2^0 = 8 + 4 + 0 + 1 = 13\)。
十进制转二进制：整数部分采用除 2 取余法（从下往上排列余数），小数部分采用乘 2 取整法（从上往下排列整数部分） 。例如，十进制整数 10 转换为二进制为1010，小数 0.625 转换为二进制为0.101。

加法：遵循 “逢二进一” 规则，如：0 + 0 = 00 + 1 = 11 + 0 = 11 + 1 = 10（本位为 0，向高位进 1）
减法：遵循 “借一当二” 规则，如10 - 1 = 1（从高位借 1 当 2，\(2 - 1 = 1\)）。
乘法：乘数为 0 结果为 0，乘数为 1 结果为被乘数，如11 × 10（即\(11\times2^1\)）结果为110。
除法：通过重复减法实现，如100 ÷ 10 = 10（从 100 中不断减 10，减 10 次完成）。

**Логические вентили**
逻辑门是实现二进制逻辑运算的基本单元，通过对输入的二进制信号（0 和 1，在电路中通常对应低电平和高电平）进行逻辑处理，输出相应的二进制信号。

1. 与门（AND Gate）：只有当所有输入均为 1 时，输出才为 1；否则输出为 0。如，输入 A=1，B=1，输出为 1；若 A=0，B=1，输出为 0。
2. 或门（OR Gate）：只要有一个或多个输入为 1，输出即为 1；只有当所有输入都为 0 时，输出才为 0。例如，输入 A=0，B=1，输出为 1；A=0，B=0，输出为 0。
3. 非门（NOT Gate）：对单个输入信号取反，输入为 0 时输出为 1，输入为 1 时输出为 0。
4. 异或门（XOR Gate）：当输入的两个信号不同时，输出为 1；当输入的两个信号相同时，输出为 0。例如，A=0，B=1，输出为 1；A=1，B=1，输出为 0。
5. 与非门（NAND Gate）：先执行与运算，再对结果取反。
6. 或非门（NOR Gate）：先执行或运算，再对结果取反。

**半加器**
半加器是实现两个一位二进制数相加的基本电路，不考虑来自低位的进位。它使用一个异或门和一个与门构建：
异或门用于计算本位和，例如输入 A 和 B，异或门输出 A⊕B ，即 A 和 B 不同时为 1，相同时为 0。
与门用于计算进位，输出 A ∧ B ，只有 A 和 B 都为 1 时，进位为 1。

**全加器**
全加器在半加器基础上，能处理两个一位二进制数相加，并考虑来自低位的进位。通常由两个半加器和一个或门组成。先将两个输入和来自低位的进位通过两个半加器进行初步运算，再利用或门将两个半加器产生的进位信号合并，得到最终的进位输出；同时，将半加器的和信号进一步处理，得到本位和输出。（在2.1.2组合电路中可见展示图和气逻辑表达式）

**算术逻辑单元（ALU）**
ALU 是计算机中央处理器（CPU）的重要组成部分，可实现多种算术和逻辑运算。它通过复杂的逻辑门组合，以及控制信号的输入，选择性地执行加法、减法、逻辑与、逻辑或等运算（通过控制信号切换不同的逻辑门组合）。

### Комбинационные схемы

Комбинационная схема --- схема, составленная из набора логических элементов, в совокупности реализующая заданную таблицу истинности. 也就是说，对于给定的输入信号组合，组合电路会根据内部的逻辑关系产生相应的输出，且输出仅取决于当前的输入，与电路过去的状态无关。

![_И,ИЛИ, НЕТ_](fig/logic-elems.png){#fig:logic-elems}
<!-- for reference: [figure](#fig:logic-elems) -->

**逻辑元件**
与逻辑门类似，是将逻辑门运用在了电子元件上：
| 逻辑元件 | 功能描述 | 真值表示例（双输入） | 应用场景 |
|----------|----------|-------------------|----------|
| 与门（AND） | 全1才为1，否则为0 | A=0,B=0→Y=0；A=1,B=1→Y=1 | 条件判断（如密码验证多条件同时满足） |
| 或门（OR） | 有1即为1，全0才为0 | A=0,B=1→Y=1；A=0,B=0→Y=0 | 多选一触发（如多个传感器任意触发报警） |
| 非门（NOT） | 信号取反 | A=1→Y=0；A=0→Y=1 | 信号极性转换 |
| 异或门（XOR） | 输入相异为1，相同为0 | A=1,B=0→Y=1；A=1,B=1→Y=0 | 数据校验、加密算法 |
| 与非门（NAND） | 先与后非，全1才为0 | A=0,B=1→Y=1；A=1,B=1→Y=0 | 通用逻辑构建（可实现其他门功能） |
| 或非门（NOR） | 先或后非，全0才为1 | A=0,B=0→Y=1；A=1,B=0→Y=0 | 低电平有效控制电路 |

![_Логическая схема_](fig/logic.png)

函数本质上是一种从集合 A 到集合 B 的映射关系，当集合 A 和集合 B 均为有限集，且可通过有限长度的二进制序列（比特序列）表示元素时，我们就能够构建组合电路来实现这种函数映射关系。
函数定义为两个集合间的对应关系，集合 A 中的每个元素在集合 B 中都有唯一确定的对应元素。例如，函数\(f(x)=2x\)，集合 A 为输入值集合，集合 B 为输出值集合，对于 A 中的每个元素x，都能在 B 中找到唯一的2x与之对应。在数字电路领域，集合 A 和 B 中的元素可通过二进制序列（即比特序列）进行表示。例如，用 “00” 表示集合 A 中的元素 A0，“01” 表示元素 A1；集合 B 中的元素也类似用二进制编码。
当集合 A 和 B 均为有限集时，意味着输入和输出的所有可能情况是可穷举的。例如，若集合 A 有 3 个元素，集合 B 有 4 个元素，那么输入输出的对应关系最多有\(3\times4 = 12\)种可能。由于这些元素能用有限长度的二进制序列表示，我们可以将输入的二进制序列视为组合电路的输入信号，输出的二进制序列视为电路的输出信号 。比如，输入 “01” 对应电路的特定输入端口电平状态，经过电路处理后输出 “10”，完成从输入到输出的映射。

Логические операции позволяют реализовать произвольную математическую функцию (см. отображение), 因为在函数中，当集合 A 和 B 均为有限集时，意味着输入和输出的所有可能情况是可穷举的。例如，若集合 A 有 3 个元素，集合 B 有 4 个元素，那么输入输出的对应关系最多有\(3\times4 = 12\)种可能。由于这些元素能用有限长度的二进制序列表示，我们可以将输入的二进制序列视为组合电路的输入信号，输出的二进制序列视为电路的输出信号。
因此我们可以实现:

**黑箱模式**
在黑箱模式下，我们不关注电路内部的具体结构和信号处理细节，而是以真值表作为核心依据。真值表完整地列出了所有可能的输入组合及其对应的输出结果，就像是一份明确的 “功能说明书” (см. курс дискретной математики Полякова: ККНД и КДНФ, минимизация булевых функций, метод Петрика, карты Карно и т.д.)。
Шаги:
1. Формирование таблицы истинности.（根据实际需求确定电路的输入变量（如开关状态、传感器信号等）和输出变量（如控制指令、运算结果等），对于 n 个输入变量，共有 \(2^n\) 种不同的输入组合。再根据电路功能要求，为每种输入组合指定相应的输出值。）
   ![Таблица истинности](image-4.png)
   {#fig:Таблица истинности}
2. Запись таблицы истинности в каноническую форму (ДНФ или КНФ), отображаемую в комбинационную схему.
   - ДНФ: 对于真值表中输出为 1 的每一行，将输入变量及其反变量（若变量值为 0 则取反）进行逻辑与（积）运算，得到一个乘积项。然后将所有输出为 1 的乘积项进行逻辑或（和）运算。例如，对于真值表中输出为 1 的行 A=1、B=0、C=1，对应的乘积项为 \(A \cdot \overline{B} \cdot C\) ；将所有此类乘积项相加，即构成 ДНФ 表达式。ДНФ 形式直接对应由与门和或门组成的组合电路，每个乘积项由一个与门实现，最终的或运算由或门完成。
    ![ДНФ](image-5.png){#fig:ДНФ}
   - КНФ: 针对真值表中输出为 0 的每一行，将输入变量及其反变量（若变量值为 1 则取反）进行逻辑或（和）运算，得到一个和项。再将所有输出为 0 的和项进行逻辑与（积）运算。КНФ 形式可由或门和与门组成电路实现，每个和项由一个或门完成，最终的与运算由与门实现。
3. Минимизация булевой функции (сокращаем размер схемы).
   - 代数化简法：依据布尔代数的基本定律和规则（如吸收律、分配律、德摩根定律等），对 DNF 或 KNF 表达式进行化简。对于简单的布尔函数，代数化简法较为有效，但对于复杂函数，可能因规则运用的灵活性导致化简困难。
   - 卡诺图法：通过将 \(2^n\) 个方格按特定规律排列（相邻方格仅有一位变量不同），将真值表中的 1 或 0 填入对应方格。对卡诺图中相邻的 1（用于 DNF 化简）或 0（用于 KNF 化简）进行合并，形成最大的矩形或正方形区域。每个合并区域对应一个化简后的乘积项或和项，从而得到最简表达式。这个方案直观易懂，能快速找到最简形式，尤其适用于变量数较少（一般不超过 6 个）的布尔函数。
   - 奎因 - 麦克拉斯基法（表格化简法）：适用于变量较多（超过 6 个）的布尔函数化简。通过构建质蕴涵项表，逐步合并最小项，去除冗余项，最终得到最简表达式。相比卡诺图，该方法更适合计算机编程实现，能处理大规模逻辑函数化简问题。
  ![Минимизация булевой функции](image-6.png){#fig:Минимизация булевой функции}

**白箱模式**
Белого ящика, когда мы понимаем особенности входных / выходных данных и их взаимосвязей, а значит, на основании этого понимания творчески оптимизируем комбинационную схему или "раскладываем" ее на многошаговый процесс.
  - 研究输入数据的范围、变化规律、数据类型，以及输出数据与输入数据之间的映射关系。
  - 根据数据特性和关系，灵活地对组合电路进行分层设计、模块化设计。比如，将复杂的电路分解为数据预处理模块、核心运算模块和结果输出模块。同时，利用对逻辑关系的深入理解，采用更高效的逻辑结构，避免冗余的逻辑门连接，实现电路的优化。
  - 将整个逻辑处理过程分解为多个步骤，每个步骤由相应的子电路完成。这样不仅便于设计、调试和维护，还可以针对每个步骤进行优化，提高整体电路的性能。

**全加器（1 - bit）**
全加器是数字电路中用于执行二进制加法运算的基本组件，能处理两个加数以及来自低位的进位输入。
求和输出（Sum）是通过对两个加数 A、B 以及进位输入（\(C_{in}\) ）进行异或（XOR）运算得到的，逻辑表达式为：Sum = A ⊕ B ⊕ \(C_{in}\) 。异或运算的特点是两个输入不同时输出为 1，相同时输出为 0。
进位输出（\(C_{out}\) ）的逻辑表达式为：\(C_{out}\) = (A ∧ B) ∨ (A ∧ \(C_{in}\)) ∨ (B ∧ \(C_{in}\)) 。这里涉及与（AND，用∧表示 ）和或（OR，用∨表示 ）运算。与运算要求两个输入都为 1 时输出才为 1；或运算则是只要有一个输入为 1 输出就为 1 。该表达式综合考虑了两个加数以及进位输入中 1 的不同组合情况，判断是否产生向高位的进位。
在二进制加法里，1 + 1 = 10（这里的 10 是二进制表示，对应十进制的 2 ） 。当两个二进制位 A 和 B 都是 1 时，即便\(C_{in}\) 为 0 ，也需产生进位。全加器通过上述进位逻辑运算，准确判断何时产生进位，并将进位信号传递到更高位。
![Полный сумматор](image-7.png)
- 输入A、B 为操作数位
- \(C_{in}\)为进位输入
- 输出 S 为和值
- \(C_{out}\)为进位输出。

**行波进位加法器**
规模：\(O(n)\)
真值表：\(O(n^2)\)
![Каскадного сумматора](image-8.png)
当我们明晰某事物的工作原理后，便能从中找出重复部分并加以抽象。如此一来，便无需反复设计，可直接复用。行波进位器（Ripple - Carry Adder，RCA），也叫行波进位加法器，是通过串行连接多个全加器所构成，各模块分别承担一位数据的相加及进位处理工作。
以两个 n 位二进制数相加为例，从最低位（第 0 位）开始，每一位的全加器都接收两个本位的加数以及来自低位的进位，进行加法运算后产生本位的和值以及向高位的进位。由于高位全加器要等待低位全加器的进位输出作为其进位输入才能进行运算，所以进位信号会像波浪一样，从低位到高位依次传递，最终产生结果。
其优点为电路布局简单，设计方便。只需设计好全加器，再将它们连接起来就能构成多位加法器。但缺点是运算速度慢 。高位的运算必须等待低位的运算完成，因为每一位的计算都依赖于前一位的进位输出，随着位数增加，延迟会显著增大。

![Сигнал со времени](image-9.png)
输入信号：A0、A1、A2 以及 B0、B1、B2 分别是参与加法运算的两个二进制数对应位的输入信号；C0 是初始进位输入信号。在二进制加法运算中，这些信号的高低电平状态代表相应位的数值（高电平通常表示 1，低电平表示 0 ）。
输出信号：S0、S1、S2 是对应位的和值输出信号；C1、C2 是对应位产生的进位输出信号。
从图中可以看到，C0 作为初始进位输入，C1 的变化依赖于 C0 以及 A0、B0 的运算结果，C2 的变化又依赖于 C1 以及 A1、B1 的运算结果。行波进位加法器的特点，就是高位的进位计算依赖于低位的进位输出，如同波浪一样依次传播。


Основные свойства любой комбинационной схемы:

- возможность установления стабильного состояния при корректном входе(нет циклов).
  组合电路的稳定状态建立依赖于其纯逻辑运算特性。由于输出仅由当前输入决定，当输入信号达到稳定电平后，电路内部逻辑门经过信号传输与运算，会在极短时间内达到最终输出状态。（例如，一个由与门构成的简单电路，当两个输入均稳定在高电平时，输出端会稳定输出高电平，且只要输入不改变，输出就保持不变。）只有确保电路处于稳定状态，才能将特定输入信号准确编码为对应二进制码；在运算器执行算术运算时，稳定的输入输出状态保证了计算结果的准确性。
- задержка установления стабильного состояния после изменения входных значений (зависит от условий окружающей среды).
  一般的延迟产生的原因有：
  门延迟：逻辑门从输入信号变化到输出响应存在固有延迟，称为门延迟
  信号传输延迟：信号在电路板走线、连接器等传输介质中传播需要时间，传输距离越长，延迟越大。
- параллельная работа элементов комбинационной схемы;
  组合电路内部逻辑门可同时对输入信号进行处理，这种并行性源于其无反馈、无记忆特性。这样会极大提升电路处理速度，满足实时性要求高的场景。并且通过并行结构，可在相同时间内处理更多数据，提高电路资源利用率。但并行工作也会增加瞬间电流需求，对电源系统提出更高要求，这个时候需要进行功耗优化设计。
- накопление ошибки в физическом процессе, что может привести к ошибке на логическом уровне.
  逻辑电路底层基于模拟信号传输，误差大多是因为外界噪声（如电源噪声、电磁辐射）会使模拟信号产生畸变；或元件存在阈值电压偏差、传输延迟不一致等非理想特性，再经过多级逻辑门后，这些微小偏差会累积放大。而这个问题可以通过缓冲器来解决。缓冲器可增强信号幅度，提高信号抗干扰能力。如使用施密特触发器作为缓冲器，可将微弱信号放大至标准逻辑电平。缓冲器可将畸变的模拟信号整形成规则的数字信号，去除噪声干扰。例如，在传感器信号采集电路中，缓冲器可将传感器输出的含噪信号转换为干净的数字信号。
- Уровень линии, не сигнал (как и с реле)
  线路电平的本质可类比为简单的二元状态，像家里电灯的开与关，在电路中体现为高电平（1 ）和低电平（0 ）。以继电器为例，它不关注信号波形细节，仅依据线路电平是否达到特定阈值来决定动作与否。在多路复用器应用中，常从信号传输路径角度思考，即信号到达后决定送往 A 点或 B 点。然而，在处理器电路实际运行里，并非单纯点对点的信号传输模式。线路电平如同为电路中的 “传输轨道” 设定方向，以高电平（1 ）或低电平（0 ）的形式快速给出指令，决定数据或信号的流向，就像扳道岔指令决定火车行驶轨道一般。
  电路在处理输入时，某些情况下更看重输入的电平状态。逻辑门判断输入是高电平还是低电平，以此来执行相应的逻辑运算。

![_Логическая схема, временная диаграмма_](fig/logic-wave-diagram.png)


*对数尺（логарифмическая линейка）*
对数尺是基于对数原理设计的计算工具。它利用对数函数的性质，将乘法和除法运算转化为对数的加法和减法运算，从而实现快速计算。例如，在对数尺上，两个数相乘，只需将它们对应的对数长度相加，再找到相加后长度对应的数值，即为乘积。
构造：通常由一把或多把带有刻度的尺子组成，刻度是按照对数规律进行划分的。常见的有滑尺式对数尺，有主尺和滑尺，通过滑动滑尺来对准不同的刻度，实现计算。
应用：在科学、工程和数学等领域广泛应用，特别是在没有电子计算器的时代，常用于快速进行乘法、除法、乘方、开方等运算，以及解决一些涉及对数关系的问题，如计算复利、解决指数方程等。

*机械式计算器（арифмометр）*
1820 年由法国发明家查尔斯・泽维尔・托马斯（Charles Xavier Thomas）发明，是第一台商业上成功的机械式计算器。它的发明受到当时工业革命的推动，满足了商业和科学领域对快速、准确计算的需求。在其发明之前，也有其他发明家尝试制造计算器，但托马斯的计算器在性能和可靠性上更胜一筹，得以大规模生产和应用。基于莱布尼茨的步进鼓机构，通过齿轮、杠杆等机械装置来实现数字的输入和运算。它有多个数位的输入机构，可进行加减法的直接运算，乘法和除法通过重复的加法和减法操作来实现。例如，要计算乘法，就需要根据乘数的大小，多次重复相加被乘数的操作。
能完成基本的四则运算，在当时的商业、金融、科学研究等领域发挥了重要作用。它使复杂的计算变得相对容易和快捷，提高了工作效率，为后续计算器和计算机的发展奠定了基础。在电子计算器出现之前，机械式计算器一直是重要的计算工具，并且在一些特定领域（如会计、统计等）得到了广泛应用。


## Особенности "последовательного исполнения"

При помощи триггеров у нас есть возможность реализовать "защёлкивание" состояния в схеме.

![_Логическая схема с состоянием_](fig/logic-with-state.png)

![_Логическая схема с состоянием, временная диаграмма_](fig/logic-with-state-wave-diagram.png)

Вход, отмеченный треугольником --- управление защёлкой состояния. Защёлкивание может происходить при разных событиях управляющего сигнала: изменение с 0 на 1 (положительный фронт), с 1 на 0 (отрицательный фронт), по состоянию (пока сигнал единичный, входное значение защёлкивается).

Это позволяет следующее:

- разбить большую комбинационную схему на несколько (использование вместо буфера);
- хранить состояние внутри схемы, а значит производить вычислительный процесс в несколько шагов (реализация счётчика, сокращение размера схемы за счёт нескольких этапов вычислений).

Важно понимать, что процессы во всех комбинационных схемах происходят параллельно, а значит, у нас открываются возможности для синхронных цифровых схем, в которых "защёлкивание" значений в триггерах происходит одновременно.

Примечания:

- одновременность весьма условна;
- синхронный сигнал должен ориентироваться на самую долгую комбинационную схему, в противном случае схема работать не сможет;
- работа с синхронной схемотехникой приводит к дискретизации аналоговых сигналов, что также вносит погрешность в работу систем (особенно систем управления).

Синхронные схемы позволяют нам делать следующее:

- Конвейеризацию вычислений (количество стадий конвейера равно количеству обрабатываемых в такт значений).
- Управлять тактовой частотой схемы, так как мы всегда можем разделить комбинационную схему триггером на часть до и после, при этом, если 1) комбинационные схемы делятся ровно пополам, то у нас нет избыточных задержек; 2) триггер имеет свою длительность срабатывания. Очевидно, что удвоение частоты в данном случае едва увеличит производительность в два раза.

## Особенности "условного оператора"

Булевы компьютеры не могут не работать. Как в таких условиях можно реализовать оператор ветвления? Есть два подхода:

- через состояние (по сути, реализован в современных процессорах, когда состояние регистров определяет следующий шаг вычислительного процесса);
- через спекулятивные вычисления и выбор результата (мультиплексор).

![_Мультиплексор (Wikipedia)_](fig/multiplexer.png){#fig:multiplexer}
<!-- for reference: [figure](#fig:multiplexer) -->

В заключение этого раздела отметим следующие моменты, принципиальные для понимания того, как работают логические компьютеры:

- все процессы между регистрами всегда происходят параллельно, последовательность обработки данных --- логическая конструкция, которая отсутствует внутри. Хотите понять, как работает --- рисуйте схему;
- нет понятия "система остановилась", она всегда будет продолжать функционировать в том или ином виде, либо будет выключена / перезагружена внешней системой (по крайней мере для синхронной схемотехники);
- передача сигнала --- физический аналоговый процесс, а значит, он не может прекратиться. Если мы не определили, какой сигнал пойдет дальше, это значит, что дальше пойдет случайный сигнал.

## Параллелизм уровня битов

Параллелизма уровня битов мы касались ранее в контексте логического базиса современных компьютеров. Подробно рассматривать этот вопрос мы не будем. Ограничимся примером и ограничениями, связанными с данным видом параллелизма.

Пример оптимизации за счёт параллелизма уровня битов для сложения бинарных чисел:

- машинное слово: 8 бит, данные: 16 бит, в таком случае сложение производится в несколько шагов:
    - сложение младших битов, фиксация бита переполнения и сохранение результата в память;
    - сложение старших битов, добавление бита переполнения (если был установлен) и сохранение результата в память;
- машинное слово: 16 бит, данные: 16 бит, сложение осуществляется в рамках большой комбинационной схемы за один такт (примечание: комбинационная схема в 16 бит будет работать на меньшей частоте, чем в 8 бит, но в данном случае эта разница несопоставима с необходимостью нескольких тактов).

Параллелизм уровня битов имеет серьёзные ограничения, так как "простые типы данных" не имеет практического смысла наращивать (к примеру, int64 более чем достаточно для подавляющего числа задач, а, значит, переход на int128 приведёт к тому, что старшие биты будут в основном "греть воздух", а в тех редких случаях, где они действительно нужны --- не факт, что их будет достаточно).

Использовать же широкое машинное слово для составных данных также затруднительно в случае процессоров общего назначения из-за их многообразия (составные данные зависят от прикладной задачи) и необходимости их поддержки на уровне системы команд (см. CISC vs RISC), без которой это теряет смысл.

На практике встречается борьба с избыточностью машинных слов в рамках специализированных решений (встроенные системы, системы на кристалле). К примеру, реализация нейронной сети на ПЛИС позволяет физически убрать лишние биты, за счёт чего снизить площадь, занимаемую схемой, и её энергопотребление.