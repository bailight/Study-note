# Базис булевых компьютеров

Все перечисленные выше компьютеры имеют не только разные принципы функционирования (от механики до электричества), но также обладают принципиально разной внутренней организацией, в частности:

- аналоговое или цифровое представление данных;
- разные системы счисления;
- разные принципы распространения информации;
- последовательность операций и что рассматривается как операция.

В этом разделе мы зафиксируем то, что можно отнести к условному базису булевых компьютеров (данное понятие не является широко распространённым и восходит к Джорджу Булю, основателю булевой логики) и принципам их функционирования.

С математической точки зрения булевый компьютер --- это компьютер, который:

- реализует булеву логику, а именно:
    - механизм представления логических значений;
    - функционально полный набор логических операций, позволяющий реализовать И, ИЛИ, НЕ;
- имеет набор триггеров, которые позволяют сохранять состояние, примечания:
    - они реализуемы в рамках чистой булевой логики, но, как правило, целесообразнее зафиксировать их как базовый элемент;
    - далее мы будем говорить в основном о D-триггерах, которые позволяют зафиксировать входной сигнал в требуемом состоянии.


Сейчас мы фокусируемся на цифровой схемотехнике и логике. 在此之前我们了解一下谢多夫分层系统发展原理与元系统跃迁，两个概念共同构成了对系统发展和演变的特定解释框架。

**谢多夫等级制度的发展原则**

揭示了复杂层次系统发展的模式和机制，其核心关键在于 “限制较低层次的多样性以获得更高层次的多样性”。其目的是为了更好地整合资源、提高效率、聚焦目标，从而为实现更高层次的多样性创造条件，提升系统整体性能和适应性。

以制作高效编译器为例，固定标准化数量的处理器，限制了处理器在数量和类型上的低层次多样性，如此便能将研发资源集中投入到编译器与这些标准化处理器的适配与优化中，提高编译效率，进而为编译器在功能、性能等更高层次实现多样性发展奠定基础。

在操作系统领域，当前市面上主流的苹果和安卓两大系统，一定程度上限制了操作系统层面的低层次多样性。这种限制促使开发者聚焦于这两大平台进行应用开发，虽然减少了操作系统种类的多样性，但却在应用层面实现了丰富的多样性，满足了用户多样化的需求。而若出现新系统，为其开发与苹果、安卓上相同功能的应用，由于缺乏统一的开发基础和生态积累，开发成本会极为高昂，难以在短期内实现应用的丰富多样。

从技术发展现状来看，处理器从架构角度数量并不繁多，编程语言的出现也呈现逐渐减少的趋势，这也反映了通过限制低层次多样性来推动更高层次发展的趋势。例如，有限的处理器架构类型使得软件开发者能够更精准地优化程序，在软件功能、兼容性等更高层次实现多样性；编程语言数量的精简，促使开发者更深入地挖掘语言特性，创造出更复杂、多样的软件应用。

**元系统转变**

元系统转变是瓦伦丁・图尔钦(Valentin Turchin)提出的概念，它描述了系统向新组织层次过渡并成为元系统的过程，即几个系统整合为一个具有新特性的更复杂系统。最好的例子如生命起源，单细胞到多细胞的进化。将一些本来互相独立的组件，如分子，细胞，个体等等的组合，突现出的系统调整和控制其间的互动。而在编程领域，这种元转变的发生则十分迅速。基于此，我们需要在新概念体系的基础上建立新的计算系统，并且该系统可以遵循不同的原则。

![_Уровни в электронных компьютерах, Харрис и Харрис_](fig/level-of-abstraction-for-computing-system.png){#fig:level-of-abstraction-for-computing-system}
<!-- for reference: [figure](#fig:level-of-abstraction-for-computing-system) -->

从应用层到物理层：
- Application Software（应用软件）：直接面向用户，满足各种具体应用需求，像办公软件、游戏等。

- Operating systems（操作系统）：管理计算机硬件与软件资源，为应用软件提供运行环境，比如 Windows、Linux 。

- Architecture（架构）：涉及计算机系统设计，包括指令集、存储结构等，决定计算机性能和功能 。

- Micro - architecture（微架构）：对计算机架构的细化，关注处理器内部具体电路、逻辑单元等设计 。

- Logic（逻辑层）：利用逻辑门等构建电路，实现基本逻辑运算，是硬件实现的逻辑基础 。

- Circuit systems（电路系统）：由各类电子元件组成电路，实现逻辑功能，传输和处理电信号 。

- Electronic devices（电子器件）：如晶体管、二极管等基础电子元件，是构建电路的基础 。

- Physical（物理层）：基于物理原理，研究电子在半导体等材料中的行为等，是计算机硬件的物理基础。

而在逻辑层上面的东西才是我们感兴趣的东西。

## Кодирование информации

### Булев базис

#### 整套布尔函数：
布尔函数是一类特殊函数，通过它能够写出任何逻辑函数，进而构建任意的计算系统。全套布尔函数包含“与”“或”“非” 这几种基本运算。此外，还有两个特殊的逻辑运算：
- **与非（谢弗行程）**：表示为 \(x|y = \overline{xy}\) ，即先对 \(x\) 和 \(y\) 进行“与”运算，再取反。
- **或非（刺穿箭头）**：表示为 \(x\downarrow y=\overline{x\vee y}\) ，即先对 \(x\) 和 \(y\) 进行“或”运算，再取反 。这两种特殊运算（与非、或非）也都可以用来写出任意逻辑函数。

**基础与构建关系**：“与” “或” “非”是最基础的布尔运算，是构建其他复杂逻辑函数的基石。任何复杂的逻辑关系都可以通过有限次地组合这三种基本运算来描述。

**等价替代关系**：“与非”和“或非”这两种运算虽然不是最基础的布尔运算，但它们具有通用性，单独使用其中任何一个（即仅通过“与非”运算，或者仅通过“或非”运算 ），就可以等价地实现“与”“或”“非”这三种基本运算所能构建出的任意逻辑函数。也就是说，在构建逻辑函数和计算系统的功能上，“与非”“或非”和“与”“或”“非”基本运算集合是等价的，可以相互替代来达成相同的逻辑表达和计算系统构建目标。 

#### Двоичное кодирование

二进制逻辑的诞生源于解决模拟系统存在的问题。在模拟系统中，数值范围太大会引发很多问题。

*模拟系统是一种通过对实际物理现象或过程进行模拟，利用物理量的连续变化来表示和处理信息的系统。在模拟电路中，电压或电流的连续变化可以用来表示声音、图像、文字等信号。*

- 级联系统中，每个阶段的转换器只要存在微小误差，经过多环节传递后，在末端转换器处就会引发信号转换的复杂偏差，导致结果难以预测。
- 电线传输过程中极易受到电磁干扰等因素影响，造成信号扭曲变形。
- 温度、湿度、材料质量等众多环境变量都会对模拟系统产生影响，导致系统工作结果不稳定、数据准确性差。

![_Logic levels and noise margins_](fig/logic-levels-and-noise-margins.png){#fig:logic-levels-and-noise-margins}
<!-- for reference: [figure](#fig:logic-levels-and-noise-margins) --> 

**Driver**（驱动端）--- 负责产生并输出信号，是信号的源头。
**Receiver**（接收端）--- 接收来自驱动端的信号，并进行处理，判断输入信号属于逻辑高电平还是逻辑低电平。
**Noise Margin High**（高电平噪声容限， \(NM\) ） --- 参数，表示在不影响接收端正确识别逻辑高或者低电平的前提下，信号在传输过程中所能容忍的最大噪声干扰幅度。
- 高电平：\(NM_H = V_{OH(min)} - V_{IH(min)}\)
- 低电平：\(NM_L = V_{IL(max)} - V_{OL(max)}\)
**Forbidden Zone** --- 位于逻辑高电平和逻辑低电平输入范围之间的区域，这个区域内的电压值，接收端无法明确判定是逻辑高电平还是逻辑低电平，会导致逻辑判断错误，所以要尽量避免信号电压落入该区域 。

二进制编码采用离散化的信息表示方式，从根本上改善了这些问题：
- 通过划定明确的电压区间，将信号抽象为逻辑 0 和逻辑 1。即使代表逻辑 0 的电流出现一定波动，只要不超出对应区间，就不会影响最终的逻辑判断。例如，在 TTL（晶体管 - 晶体管逻辑）电路中，规定低于 0.8V 为逻辑 0，高于 2V 为逻辑 1 ，处于 0.8 - 2V 之间的区域就是禁区（forbidden zone）。实际的电流信号会落在噪声容限（Noise Margin，NM）区间内，这一区间保证了信号在存在一定干扰的情况下，仍能被准确识别。
- 二进制算术相较于十进制，从硬件实现角度更为简便。二进制仅需处理 0 和 1 两种状态，基本算术运算（如加法、减法）可通过简单的逻辑门电路（与门、或门、非门等）实现。而十进制需要设计更复杂的电路来处理 0 - 9 十种状态。
- 通过增加二进制数的位数（即位宽），可以线性扩展数值表示的范围和精度。例如，8 位二进制数能表示的无符号整数范围是 0 - 255，而 16 位二进制数则可扩展至 0 - 65535 。又在表示小数时，也可以通过固定小数点位置（定点数）或采用科学计数法形式（浮点数），利用增加位数来提升精度，这种通过位宽扩展实现的数值表达能力提升，是二进制系统的重要特性。
- 二进制系统的误差是 “设计决定”（by design），而非 “实现导致”（by implementation）。这意味着，只要计算机硬件遵循相同的二进制设计标准，在相同的输入条件下，不同计算机（只要功能正常）将产生相同的计算结果。这种确定性使得二进制系统在数据处理和程序运行上具有高度一致性，极大方便了软件开发、系统调试和数据交互，避免了因硬件实现差异（温度等众多环境变量）导致的计算结果不一致问题。

![Аналоговый и цифровой сигнал](image.png)

Недостатки:

- Нечеловеческое представление ("а и не надо", бинарные часы，其显示形式与人类习惯的时间读取方式差异明显，需要专门学习和转换才能理解).
- Простые десятичные числа записываются в виде бесконечных двоичных дробей. 十进制的 0.1转换为二进制后是无限循环小数。这不仅在存储和计算时需要特殊处理，容易产生精度损失。尤其在对数据准确性要求极高的银行系统中，货币计算必须保证分毫不差，不能出现金额丢失或凭空增加的情况。因此，银行系统通常直接对整数进行计算，例如将金额以 “分” 为单位表示成整数，从而规避因二进制小数精度问题可能引发的计算误差。
- Дискретное кодирование сигнала (точность) 需要将连续模拟信号通过采样和量化转换为数字信号。量化时，因只能将信号映射到有限个离散值，必然产生误差。

На самом деле, работа с бинарной логикой на практике часто требует работы с тремя, а то и четырьмя состояниями (использован синтаксис языка описания аппаратуры Verilog):

- `0` и `1`;
- `z` --- 高阻态，表示断开或悬空状态，即数据源（导线）未连接有效信号，不存储逻辑 0 或 1 的数值。在实际电路中，这种状态常用于总线架构设计，当多个设备连接到同一条总线上时，未被选中的设备可以将自身输出设置为高阻态，避免对总线信号产生干扰，从而实现多个设备对总线资源的分时复用。这也是实际应用中常出现用两个正物理电平对二进制状态进行编码的原因之一。
- `x` --- 未知态，代表不确定或任意值。在电路实现中，当出现如除法器除以 0 这类无定义操作时，其输出数据便处于未知态；另外，在数字电路的锁存器之间发生同步错误时，也可能捕获到错误的、无法确定的数值，此时该信号状态即为 x。

<!-- TODO: добавить отступление по конкретным форматам представления чисел (двоично-десятичное представление (точность расчетов в десятичной системе у дробей, простота вывода для пользователя), фиксированная точка, дополнительный код, плавающая точка), бинарной арифметике и её реализации через бинарную логику. -->

##### Формат представления чисел
**двоично-десятичное представление**
- точность расчетов в десятичной системе у дробей
- простота вывода для пользователя
**фиксированная точка**
**дополнительный код**
**плавающая точка**

##### Бинарной арифметике и её реализации через бинарную логику

---

### Комбинационные схемы

Комбинационная схема --- схема, составленная из набора логических элементов, в совокупности реализующая заданную таблицу истинности.

![_И,ИЛИ, НЕТ_](fig/logic-elems.png){#fig:logic-elems}
<!-- for reference: [figure](#fig:logic-elems) -->

![_Логическая схема_](fig/logic.png)

Логические операции позволяют реализовать произвольную математическую функцию (см. отображение), причем это может быть реализовано для:

- черного ящика, когда мы реализуем таблицу истинности (см. курс дискретной математики Полякова: ККНД и КДНФ, минимизация булевых функций, метод Петрика, карты Карно и т.д.);
- белого ящика, когда мы понимаем особенности входных / выходных данных и их взаимосвязей, а значит, на основании этого понимания творчески оптимизируем комбинационную схему или "раскладываем" ее на многошаговый процесс.

Основные свойства любой комбинационной схемы:

- возможность установления стабильного состояния при корректном входе;
- задержка установления стабильного состояния после изменения входных значений (зависит от условий окружающей среды);
- параллельная работа элементов комбинационной схемы;
- накопление ошибки в физическом процессе, что может привести к ошибке на логическом уровне.

Последняя проблема решается при помощи буфера, который "выравнивает" аналоговый сигнал, лежащий в основе логического.

![_Логическая схема, временная диаграмма_](fig/logic-wave-diagram.png)

## Особенности "последовательного исполнения"

При помощи триггеров у нас есть возможность реализовать "защёлкивание" состояния в схеме.

![_Логическая схема с состоянием_](fig/logic-with-state.png)

![_Логическая схема с состоянием, временная диаграмма_](fig/logic-with-state-wave-diagram.png)

Вход, отмеченный треугольником --- управление защёлкой состояния. Защёлкивание может происходить при разных событиях управляющего сигнала: изменение с 0 на 1 (положительный фронт), с 1 на 0 (отрицательный фронт), по состоянию (пока сигнал единичный, входное значение защёлкивается).

Это позволяет следующее:

- разбить большую комбинационную схему на несколько (использование вместо буфера);
- хранить состояние внутри схемы, а значит производить вычислительный процесс в несколько шагов (реализация счётчика, сокращение размера схемы за счёт нескольких этапов вычислений).

Важно понимать, что процессы во всех комбинационных схемах происходят параллельно, а значит, у нас открываются возможности для синхронных цифровых схем, в которых "защёлкивание" значений в триггерах происходит одновременно.

Примечания:

- одновременность весьма условна;
- синхронный сигнал должен ориентироваться на самую долгую комбинационную схему, в противном случае схема работать не сможет;
- работа с синхронной схемотехникой приводит к дискретизации аналоговых сигналов, что также вносит погрешность в работу систем (особенно систем управления).

Синхронные схемы позволяют нам делать следующее:

- Конвейеризацию вычислений (количество стадий конвейера равно количеству обрабатываемых в такт значений).
- Управлять тактовой частотой схемы, так как мы всегда можем разделить комбинационную схему триггером на часть до и после, при этом, если 1) комбинационные схемы делятся ровно пополам, то у нас нет избыточных задержек; 2) триггер имеет свою длительность срабатывания. Очевидно, что удвоение частоты в данном случае едва увеличит производительность в два раза.

## Особенности "условного оператора"

Булевы компьютеры не могут не работать. Как в таких условиях можно реализовать оператор ветвления? Есть два подхода:

- через состояние (по сути, реализован в современных процессорах, когда состояние регистров определяет следующий шаг вычислительного процесса);
- через спекулятивные вычисления и выбор результата (мультиплексор).

![_Мультиплексор (Wikipedia)_](fig/multiplexer.png){#fig:multiplexer}
<!-- for reference: [figure](#fig:multiplexer) -->

В заключение этого раздела отметим следующие моменты, принципиальные для понимания того, как работают логические компьютеры:

- все процессы между регистрами всегда происходят параллельно, последовательность обработки данных --- логическая конструкция, которая отсутствует внутри. Хотите понять, как работает --- рисуйте схему;
- нет понятия "система остановилась", она всегда будет продолжать функционировать в том или ином виде, либо будет выключена / перезагружена внешней системой (по крайней мере для синхронной схемотехники);
- передача сигнала --- физический аналоговый процесс, а значит, он не может прекратиться. Если мы не определили, какой сигнал пойдет дальше, это значит, что дальше пойдет случайный сигнал.

## Параллелизм уровня битов

Параллелизма уровня битов мы касались ранее в контексте логического базиса современных компьютеров. Подробно рассматривать этот вопрос мы не будем. Ограничимся примером и ограничениями, связанными с данным видом параллелизма.

Пример оптимизации за счёт параллелизма уровня битов для сложения бинарных чисел:

- машинное слово: 8 бит, данные: 16 бит, в таком случае сложение производится в несколько шагов:
    - сложение младших битов, фиксация бита переполнения и сохранение результата в память;
    - сложение старших битов, добавление бита переполнения (если был установлен) и сохранение результата в память;
- машинное слово: 16 бит, данные: 16 бит, сложение осуществляется в рамках большой комбинационной схемы за один такт (примечание: комбинационная схема в 16 бит будет работать на меньшей частоте, чем в 8 бит, но в данном случае эта разница несопоставима с необходимостью нескольких тактов).

Параллелизм уровня битов имеет серьёзные ограничения, так как "простые типы данных" не имеет практического смысла наращивать (к примеру, int64 более чем достаточно для подавляющего числа задач, а, значит, переход на int128 приведёт к тому, что старшие биты будут в основном "греть воздух", а в тех редких случаях, где они действительно нужны --- не факт, что их будет достаточно).

Использовать же широкое машинное слово для составных данных также затруднительно в случае процессоров общего назначения из-за их многообразия (составные данные зависят от прикладной задачи) и необходимости их поддержки на уровне системы команд (см. CISC vs RISC), без которой это теряет смысл.

На практике встречается борьба с избыточностью машинных слов в рамках специализированных решений (встроенные системы, системы на кристалле). К примеру, реализация нейронной сети на ПЛИС позволяет физически убрать лишние биты, за счёт чего снизить площадь, занимаемую схемой, и её энергопотребление.







数字电路的要素：








组合电路；
当使用大量的与或者非，不用深入研究细节

触发器——存储状态。
后面会讲关于存储设备，而现在我们需要触发器是如何工作的，我们不在乎他到底在哪，只要在较低的抽象层次就可以了。