# Архитектура проложения


**Архитектура 架构** — логическая и физическая структура системы, сформированная всеми стратегическими и тактическими проектными решениями. (Г. Буч.)

逻辑与物理结构的统一，由所有战略级和战术级设计决策构成（Г. Буч）；具体是软件系统组织的关键决策集合，涵盖结构元素选择、接口设计、元素交互行为、元素组合方式及架构风格。

- Архитектура программного обеспечения – это ряд значительных решений об 
организации программной системы, выборе структурных элементов и их 
интерфейсов, с помощью которых собирается система, а так же их поведение во взаимодействии с этими элементами, объединение этих структурных и 
поведенческих элементов в большие системы и архитектурный стиль этой 
организации – этих элементов и их интерфейсов, их взаимодействия и их 
объединения.

软件架构是一系列关于软件系统组织方式的重要决策，包括结构元素及其接口的选择、这些元素之间的交互以及它们在交互中的行为。它还包括将这些结构元素和行为元素集成到更大的系统中，以及这种组织方式的架构风格——这些元素及其接口、交互和集成方式。

- Архитектура объясняет концепцию работы вашей системы, как ваша система 
устроена внутри, как работает, как ее делать, отлаживать, сопровождать и 
использовать.

架构解释了系统的概念、内部结构、运行方式、构建方法、调试方法、维护方法以及如何使用方法。

>1. 不仅是 “系统骨架”，更是沟通工具（让不同角色理解系统）、简化工具（分解复杂系统）、风险控制工具（提前规避设计缺陷）。
>2. 架构描述需高于编程语言层面，避免陷入 “仅关注语法 / 框架” 的局部视角，实现全局把控。

---

**结构与架构 Структура и архитектура**

- Структура это совокупность элементов и связей между ними
- Архитектура – более ёмкое понятие, включающее в себя множество структур.
- В рамках любой модели вычислений систему можно представить как структуру, в виде совокупности акторов и связей между ними

- 结构是指元素及其相互关系的集合。
- 架构是一个更全面的概念，涵盖多种结构。
- 在任何计算模型中，系统都可以表示为一个结构，即参与者及其相互关系的集合。

---

**结构与图 Структура и графы**

- Любую структуру в вычислительной технике можно изобразить в виде графа
  计算机中的任何结构都可以用图来表示。
- Граф это совокупность вершин (кружочков или квадратиков) и ребер (стрелочек)
  图是由顶点（圆圈或正方形）和边（箭头）组成的集合。
- Вопрос в том, что вы должны понимать, что означают эти кружочки/квадратики, а что означают стрелочки в ВАШЕМ конкретном случае. Если вы не понимаете семантику элементов схемы, ваша схема не имеет смысла!
  关键在于，你必须理解这些圆圈/正方形的含义，以及箭头在你具体情况下的含义。如果你不理解图元素的语义，你的图就毫无意义！
- От наполнения (семантики, смысла) этих элементов графа зависит то, что за структуру вы нарисовали.
  这些图元素的内容（语义、含义）决定了你绘制的结构类型。
  Это может быть:
  - Структурная схема вашего оборудования 设备框图
  - Диаграмма потоков данных или сеть процессов Кана 数据流图或 Kahn 过程网络
  - Конечный автомат 有限状态机
  - Блок-схема алгоритма 算法流程图
  - Электрическая принципиальная схема 电路图
  - Диаграмма классов 类图

---

**为什么我们需要架构？**

- 理解系统
- 简化系统
- 解释系统的结构和工作原理
- 对程序有清晰的构想（增加成功率）

Нужно учиться думать на различных уровнях абстракции, пользоваться разными описаниями системы. Язык описания архитектуры– выше по уровню чем любой язык программирования, он позволяет увидеть систему целиком, с высоты «птичьего полета».

我们需要学习在不同的抽象层次上思考，并使用不同的系统描述方式。架构描述语言比任何编程语言都更高层次；它使我们能够从全局视角看待系统。

---

**我们将如何描述这个项目？**

- Максимально просто, но не проще, чем это необходимо.
  尽可能简单，但不能过于简单。
- Используйте принцип KISS (Keep it simple, stupid» — «Делай проще, тупица») по 
максимуму.
  尽可能遵循 KISS（Keep it simple, stupid，保持简单，笨蛋）原则。

---

**Модель вычислений**

- *Модель вычислений, вычислительная модель* (model of computation, MOC) — *набор законов* взаимодействия элементов вычислительной системы.
计算模型 (MOC) 是一组用于规范计算系统各元素间交互的规则。

- *Модель вычислений* - *набор правил* организации вычислительного процесса, в рамках которых возможен его формальный анализ.
计算模型是一组用于组织计算过程的规则，在该规则框架内可以对其进行形式化分析。

- *Модель вычислений* - *набор формальных правил*, в рамках которых организована взаимосвязь и поведение множества составляющих атомарных частей модели некоторой вычислительной системы.
计算模型是一组形式化规则，用于组织计算系统模型中多个组成原子部分的相互关系和行为。

- *Модель вычислени*й - *строго определенная парадигма* (набор правил),описывающая протекание вычислительного процесса, способы обмена данными,  взаимодействия между отдельными функциональными элементами.
计算模型是一组形式化规则，用于组织计算系统模型中多个组成原子部分的相互关系和行为。

- *Модель вычислений* - *недвусмысленный формализм* для представления  спецификаций проекта и проектных решений.
计算模型是一个严格定义的范式（规则集），用于描述计算过程的流程、数据交换方法以及各个功能元素之间的交互。

- *Модель вычислений* - *математическая модель*, демонстрирующая пользователю вычислительные возможности вычислителя и правила их использования.
计算模型是一种明确的形式化方法，用于表示项目规范和设计决策。

---

**Контекст системы**

- Контекст системы позволяет отделить то, что вы обязаны сделать в рамках ТЗ от того, что вы делать не должны.
  系统上下文允许您将职责范围内必须做的事情与禁止做的事情区分开来。
- Контекст системы представлен в виде круга (это процесс) к которому подходят стрелки (потоки данных от внешних сущностей)
  系统上下文用一个圆圈（代表流程）表示，箭头（代表来自外部实体的数据流）指向圆圈。

---

**Внешняя сущность**

- 这是我们的系统通过某些通信渠道与之交互的对象。 
- 该外部实体的结构和功能我们无需特别关注。
- 对我们而言，最重要的是如何与外部实体正确交换数据。

换句话说，我们关注两件事：

- 接口，
- 交换协议。

---

**Классификация**

Классификация – декомпозиция системы на объекты, которые в свою очередь выстроены в виде иерархии.

分类是将一个系统分解成若干对象，并将这些对象按层级结构排列的过程。

---

**Зачем нужно объектно-ориентированное программирование?**

- Классификация объектов переносится с бумаги в исходный текст программы.
  对象分类从纸面转移到程序源代码中。
- Это заставляет программиста лишний раз задуматься и сделать непротиворечивую классификацию
  这迫使程序员仔细思考并创建一致的分类。
- Система типов (каждый класс имеет свой тип) не дает делать грубые ошибки
  类型系统（每个类都有自己的类型）可以防止严重的错误。
- Структура программы становится более прозрачной и простой
  程序结构变得更加透明和简洁。
- Упрощается использование объектов за счет абстракции (выделения главного)
  通过抽象（突出本质）简化对象的使用。
- Лишнее, ненужное и опасное прячется внутри объектов (инкапсуляция)
  对象内部隐藏了不必要、不必要和危险的信息（封装）。
- Одинаковый по смыслу метод, например, `send(message : String)`, позволяет в разных классах делать разные вещи: отправить сообщение в брокер сообщений, в очередь для связи с другим потоком, на принтер, в файл лога и т.п.
  同一个方法，例如 `send(message: String)`，可以在不同的类中执行不同的操作：向消息代理发送消息、向队列发送消息以与其他线程通信、向打印机发送消息、向日志文件发送消息等等。
- Уменьшается объем кода (за счет того, что реализация частей сложных объектов как бы выносится за скобки)
  减少代码量（因为复杂对象的部分实现被提取出来）。
- Упрощается отладка
  简化调试。
- Упрощается сопровождение кода
  减少代码维护

因此，我们可以用相同的程序员技能编写更大的程序。

---

**Что не умеет делать ООП?**

Классификация дает вам возможность создать более-менее стройную иерархию строительных частей вашей программы, не более. Причем этот процесс не защищает вас от ошибок и разных противоречий
  
分类只能帮助你构建一个大致连贯的程序模块层级结构，仅此而已。此外，这个过程并不能避免错误和各种不一致之处。

- ООП не поможет вам справиться с асинхронными процессами
  OOP 无法处理异步进程
- ООП не может решить проблему сложного поведения объектов
  OOP 无法解决复杂对象行为的问题
- ООП вам не поможет в создании алгоритмов связанных с решением задач в рамках заданного времени
  OOP 无法帮助创建在给定时间范围内解决问题的算法（实时系统）
- ООП не даст вам способов решения задач экономии энергии или распределения процессов по вычислительным узлам
  OOP 无法解决能量守恒问题或将进程分布到不同的计算节点上


---

**Что собой представляют кирпичики нашей программы?**

程序的基本单元是构建完整软件系统的核心组件，其本质、设计逻辑与价值可总结如下：

构成程序的基本单元包括函数、对象、变量等，但其核心属性并非单纯的“编程语言语法元素”，而是**用于描述目标系统的“语言组件”** ——这里的“语言”并非指C++、Java、Kotlin、C#、Go等具体编程语言，而是一套用于建模系统的概念体系。

具体来说：
- 编程语言仅提供基础语法规则与技术框架，相当于“建筑施工的工具与材料标准”；
- 函数、对象、变量等基本单元则是基于这套框架构建的“具体构件”，通过组合这些构件，才能形成具备完整功能的系统；
- 所有编程语言的底层都依赖**计算模型**（组织计算过程的规则集合），若某编程语言支持多种计算模型，则被称为“多范式语言”。

创建程序的基本单元时，必须遵循两大核心约束：
1. 契合编程语言的核心概念（即其底层计算模型），不可违背语言的设计逻辑；
2. 适配系统的运行环境，确保单元之间、单元与环境之间能够兼容协作。

这些基本单元并非被动的“构件”，而是具备扩展系统能力的核心载体：
- 通过组合基础单元，可在现有计算模型之上构建**全新的计算模型**（例如实现操作系统式的任务切换器，或具备全新属性的虚拟机）；
- 这种扩展本质是创建了新的**抽象层**，让程序能够突破原有语言或模型的限制，应对更复杂的业务场景。

基本单元的功能与表达能力，受其所属的“概念语言”（而非编程语言）的局限性约束：
1. 若“概念语言”缺乏对应词汇（即无适配的基本单元类型），要么只能迂回、晦涩且冗长地描述系统，要么完全无法描述——例如用C++难以创作诗歌，用俄语不便求解微分方程，而古代人类的语言中根本没有与软件开发相关的概念；
2. 任何“概念语言”都有其适用领域：对某些场景描述高效精准，对其他场景则力不从心（例如用小学生的知识概念，无法清晰描述核反应堆内部的物理过程）；
3. 编程领域同理：若可用的基本单元（概念集合）与某一特定算法不匹配，就无法准确、高效地实现该算法——正如《平面国》的居民无法理解三维世界的维度概念一样。

---

**Сети процессов Кана 卡恩过程网络**

Сети процессов Кана являются удобным инструментом для 
изображения взаимодействующих  процессов.
卡恩过程网络是描述交互过程的便捷工具。

Process Network (PN), сеть процессов Кана, сеть потоков данных - модель вычислений, в которой система представляется в виде ориентированного графа, вершины которого представляют собой процессы (вычисления), а дуги представляют собой упорядоченные последовательности элементов 
данных.

过程网络（PN），也称为卡恩过程网络或数据流网络，是一种计算模型，其中系统被表示为一个有向图，图的节点代表过程（计算），图的边代表有序的数据元素序列。

---

**工作流程**

- 工作流程（序列图）可以帮助您了解进程间消息交换的顺序。
- 该场景图可以显示：
    - 消息类型
    - 哪个进程发送消息，哪个进程接收消息
    - 响应消息所需的时间
    - 如果未收到消息会发生什么情况
    - 该场景图并未显示进程间所有可能的数据交换。

---

**конечный автомат, автомат**

конечный автомат, автомат — модель вычислений предполагающая наличие состояний объекта, переходов от состояния к состоянию и условий перехода.
有限状态机（FSM）或有限自动机是一种计算模型，它假定对象状态的存在、状态间的转换以及转换条件。

Конечный автомат - математическая модель устройства с конечной памятью.
有限状态机是具有有限内存的设备的数学模型。

Конечный автомат перерабатывает множество входных дискретных сигналов в 
множество выходных сигналов. Различают синхронные и асинхронные конечные 
автоматы.
有限状态机将一组离散的输入信号处理成一组输出信号。有限状态机分为同步有限状态机和异步有限状态机。

Конечный автомат в теории алгоритмов - математическая абстракция, 
позволяющая описывать пути изменения состояния объекта в зависимости от 
его текущего состояния и входных данных, при условии что общее возможное 
количество состояний конечно. Конечный автомат является частным случаем 
абстрактного автомата.
在算法理论中，有限状态机是一种数学抽象，它允许描述对象状态变化的路径，该路径取决于对象的当前状态和输入数据，前提是状态总数是有限的。有限状态机是抽象自动机的一个特例。

---

**Структурная схема**

- 展示系统硬件模块组成及接口连接方式，聚焦所需线路与传输标准，不关注具体传输数据
- 与 Kahn 进程网络、状态机同源的图模型，需明确元素（如方块、箭头）语义才有效
- 不可混合不同语义元素（如硬件组件与软件状态、进程），保持逻辑一致

---

**Словарь позволяет описать**

- Аппаратные блоки 硬件模块
- Интерфейсы 接口
- Процессы 进程
- Потоки данных 数据流
- Состояния 状态
- Условия переходов и действия 转换条件和操作

 