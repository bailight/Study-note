# Память, планирование

## 39. Управление памятью, основные определения и требования к организации.

Управление памятью: основные определения и организационные требования

**Основные определения**

*   Основная память: область памяти, где процессор может непосредственно выполнять программы, обычно ОЗУ.
*   Вспомогательная память: область для хранения программ и данных, например, жесткий диск, где программы могут находиться даже во время выполнения.
*   Фрейм (Кадр): блок фиксированного размера в основной памяти, базовая единица выделения физической памяти.
*   Страница: блок фиксированного размера во вспомогательной памяти, который может быть загружен в фрейм основной памяти, базовая единица виртуальной памяти.
*   Сегмент: логическая область в памяти переменного размера, которая может быть далее разделена на страницы; часто используется для организации различных частей программы (например, сегмент кода, сегмент данных).

**Требования к организации**

*   Перемещаемость: программа должна иметь возможность быть перемещённой в памяти; требует аппаратной поддержки (например, базовых регистров) для повышения эффективности.
*   Защита: предотвращение доступа процесса к областям памяти, ему не принадлежащим; обычно реализуется аппаратными механизмами (например, ключи защиты памяти, биты прав доступа в таблице страниц).
*   Совместное использование: позволяет нескольким процессам совместно использовать одну и ту же область памяти (например, общие библиотеки, данные), повышая утилизацию памяти.
*   Логическая организация: управление памятью должно поддерживать модульную структуру программ, упрощая организацию кода, данных и стека.
*   Физическая организация: аппаратная поддержка, техника оверлеев, виртуализация и управление пространством подкачки.

## 40. Фиксированное и динамическое размещение программ в памяти.

Фиксированное и динамическое размещение программ в памяти

**Фиксированные разделы**

Память заранее разделена на разделы фиксированного размера (например, 64КБ, 128КБ, 256КБ и т.д.).
В каждый раздел может быть загружена только одна программа.

Недостатки:
Если программа меньше раздела, оставшееся пространство тратится впустую — это называется внутренней фрагментацией.
Если размер процесса превышает размер раздела, должна использоваться техника оверлеев, самостоятельно загружая и выгружая части кода.

**Динамические разделы**

`malloc` и `free`

Память не разделяется заранее, а динамически выделяется процессам непрерывными блоками необходимого размера по требованию.
ОС находит свободный блок в памяти для загрузки процесса.

Недостатки:
Фрагментация памяти: после частых выделений и освобождений в памяти появляется множество небольших несмежных свободных блоков (внешняя фрагментация).
Требуется уплотнение памяти: для объединения свободных блоков иногда необходимо перемещать загруженные программы (перемещение).
В начале хорошо, но в итоге производительность ухудшается из-за фрагментации.
Алгоритмы выделения сложны и медленны (например, первый подходящий, наилучший подходящий, наихудший подходящий и др.).

Преимущества:
Утилизация памяти выше, чем при фиксированных разделах.
Нет внутренней фрагментации (размер выделенного блока равен размеру процесса).
Более подходит для динамической загрузки драйверов.

**Компромиссный подход — Buddy System / Система "приятелей"**

Компромиссный подход, при котором память разделяется на блоки размером 2^k.

*   При выделении, если не находится блок подходящего размера, больший блок делится пополам (на два "приятельских" блока).
*   При освобождении, если оба "приятельских" блока свободны, они объединяются в один блок большего размера.

Преимущества:
*   Уменьшает внешнюю фрагментацию.
*   Выделение и освобождение происходят быстрее (через операции слияния и разделения).

Часто используется для управления физической памятью в ядре Linux.

## 41. Модели аппаратного перемещения программ.

Модели аппаратного перемещения программ

Копировать программы средствами ОС — долго!
Только программное копирование и перемещение программ операционной системой неэффективно, так как требует большого объема копирования памяти и пересчёта адресов.

Нужна аппаратная поддержка, например, как в 8086
Для повышения эффективности требуется аппаратная поддержка, например, механизм сегментных базовых регистров, представленный в процессоре Intel 8086.

**Модель 8086**
Логический адрес разделён на две части: сегмент и смещение.
Сегментные регистры содержат базовый адрес сегмента.
Сумматор складывает (базовый адрес сегмента × 16) со смещением, генерируя физический адрес.
Когда программу нужно переместить, достаточно обновить базовый адрес в сегментном регистре; аппаратура автоматически вычисляет новый физический адрес при обращении к памяти.

**Базовая модель**

MMU (Блок управления памятью)
*   Содержит базовый и предельный регистры (Base and Limit Registers) для перемещения и защиты.
*   Адресное пространство каждого процесса с помощью базового регистра отображается в разные области физической памяти.

*   Использует таблицу страниц для отображения виртуальных адресов на физические.
*   Когда программа или данные перемещаются, достаточно обновить номер физического кадра в таблице страниц, не перемещая реальные данные (доступ к которым может вызвать исключение страничного сбоя).

## 42. Простой страничный подход и простая сегментная организация.

Простой страничный подход и простая сегментная организация

**Простой страничный подход**

Основная память разделена на кадры фиксированного размера.
Адресное пространство процесса (виртуальная память) разделено на страницы того же размера, что и кадры.
Для удобства вычисления адресов размер страницы/кадра обычно равен степени двойки (например, 4КБ).

Преимущества:
*   Уменьшает внутреннюю фрагментацию: у каждого процесса только последняя страница может быть не полностью заполнена, потраченное впустую пространство не превышает размера одной страницы.
*   Внешняя фрагментация полностью устранена: так как все страницы/кадры одного размера, любой свободный кадр может быть выделен любой странице любого процесса.

*   Требуется таблица страниц для поддержания соответствия между виртуальными страницами и физическими кадрами.
*   Каждый процесс имеет свою таблицу страниц, управляемую операционной системой.

**Простая сегментная организация**

Память разделена на логические сегменты, размер каждого сегмента может быть переменным (например, сегмент кода, сегмент данных, сегмент стека).
Программист или компилятор должен явно определить длину и базовый адрес каждого сегмента.
ОС управляет базовым адресом, длиной и правами доступа каждого сегмента через таблицу сегментов.

Преимущества:
*   Нет внутренней фрагментации: размер каждого сегмента в точности равен его фактическим потребностям.
*   Внешняя фрагментация уменьшена: по сравнению с динамическими разделами, размер сегментов более соответствует логической структуре, степень фрагментации ниже.
*   Логичность: лучше соответствует естественной структуре программ, упрощает совместное использование и защиту (например, сегмент кода только для чтения, сегмент данных для записи).

Структура:
Каждая запись содержит базовый адрес сегмента, предел сегмента, права доступа и т.д.
Аппаратура должна предоставлять сегментные регистры для поддержки механизма сегментации.

Таблица страниц:
Многоуровневое отображение: процесс → виртуальная страница → физический кадр.
Скрытие непрерывности при страничной организации: виртуальные страницы могут размещаться в физической памяти не непрерывно.

Таблица сегментов:
Каждый сегмент имеет базовый адрес и длину.
Разные сегменты хранятся в памяти отдельно, у каждого своё назначение и права доступа.

## 43. Виртуальная память основные определения и принципы организации аппаратуры и управляющих программ.

Виртуальная память: основные определения и принципы организации аппаратного и программного обеспечения

**Основные определения**

Реальный (физический) адрес — адрес в основной памяти
Реальный (физический) адрес — фактический адрес в основной памяти (ОЗУ).

Виртуальный адрес — логический адрес внутри процесса
Виртуальный адрес — логический адрес, используемый внутри процесса, генерируемый ЦП.

Адресное пространство — диапазон адресов процесса
Адресное пространство — диапазон адресов, которые процесс может использовать.

Виртуальное адресное пространство — область для одного процесса с виртуальными адресами
Виртуальное адресное пространство — область виртуальных адресов, используемая одним процессом.

Виртуальная память — это схема управления памятью, при которой:
*   Вспомогательная память (например, диск) и основная память адресуются единым образом.
*   Виртуальные адреса могут быть преобразованы в физические.
*   Основная память может быть расширена за счёт вспомогательной.
*   Размер памяти ограничен схемой адресации, а не фактической ёмкостью физической памяти.

**Принципы организации аппаратного обеспечения**

*   Организация виртуальной памяти является результатом совместной работы аппаратного и программного обеспечения.
*   Реализация объединяет два механизма преобразования адресов: страничную и сегментную.
    *   Логические адреса динамически преобразуются в физические.
    *   Сегменты и страницы не обязаны храниться в физической памяти непрерывно.
    *   Любая часть процесса в разные моменты выполнения может находиться во вспомогательной памяти, и её физический адрес в основной памяти может меняться.
*   Резидентная часть: часть процесса, находящаяся в данный момент в основной памяти.
*   Реальная память: часть физической памяти, фактически используемая выполняющимся процессом.
*   Виртуальная память: всё адресное пространство, доступное процессу (включая части, которые могут находиться на диске).

Таким образом, операционная система может одновременно управлять большим количеством процессов (благодаря технике виртуальной памяти, обеспечивающей изоляцию и расширение памяти между процессами).

## 44. Виртуальный страничный обмен. Двухуровневая организация MMU и TLB 80386. (для КОТ и ГТ — общие принципы)

Виртуальный страничный обмен. Двухуровневая организация MMU и TLB в 80386. (Общие принципы для COT и GT)

**Виртуальный страничный обмен**

Виртуальное страничное преобразование — ключевой механизм реализации виртуальной памяти.
Логическое адресное пространство делится на страницы фиксированного размера.
Физическая память делится на кадры такого же размера.
С помощью таблицы страниц устанавливается отображение виртуальных страниц на физические кадры.

Типы таблиц страниц:
*   Одноуровневая таблица страниц: простая и прямая, но сама таблица может быть слишком большой и занимать непрерывную память.
*   Многоуровневая таблица страниц (например, двух-, четырёх-, пятиуровневая): иерархическая структура, экономит память, поддерживает большое адресное пространство.
*   Инвертированная таблица страниц: ориентирована на физические кадры, экономит пространство, но поиск требует хеширования или цепочек.

Таблица страниц хранится в основной памяти.
Для доступа к памяти необходимо выполнять несколько обращений к памяти.
TLB кэширует недавно использованные записи таблицы страниц, ускоряя преобразование адресов.

**Двухуровневая организация MMU и TLB в 80386**

Процессор 80386 использует двухуровневую структуру таблиц страниц:

*   Уровень 1: Каталог страниц (Page Directory)
*   Уровень 2: Таблица страниц (Page Table)

Виртуальный адрес делится на три части:

*   Индекс в каталоге страниц (10 бит)
*   Индекс в таблице страниц (10 бит)
*   Смещение внутри страницы (12 бит) → соответствует размеру страницы 4КБ

> Регистр CR3 содержит физический базовый адрес каталога страниц текущего процесса.
Индекс в каталоге страниц используется для нахождения базового адреса таблицы страниц в каталоге.
Индекс в таблице страниц используется для нахождения номера физического кадра в таблице страниц.
Номер физического кадра + смещение внутри страницы = физический адрес.

**Роль TLB в 80386**

TLB в 80386 кэширует отображение номера виртуальной страницы на номер физического кадра.
При попадании в TLB нет необходимости обращаться к двухуровневым таблицам страниц, номер физического кадра получается напрямую.
При промахе в TLB необходимо пройти по двухуровневым таблицам страниц и поместить результат в TLB.

## 45. Инвертированная таблица страниц.

Инвертированная таблица страниц

Инвертированная таблица страниц — таблица, в которой записи соответствуют физическим кадрам (а не виртуальным страницам).

Традиционная таблица страниц индексируется по виртуальным страницам, у каждого процесса своя.
Инвертированная таблица страниц индексируется по физическим кадрам, одна на всю систему.
Каждая запись указывает: какой виртуальной страницей какого процесса занят данный физический кадр.

Поскольку инвертированная таблица страниц индексируется по физическим кадрам, для нахождения физического адреса по заданному виртуальному требуется поиск по всей таблице.

Хеш-таблица: хеширование (PID, VPN) для быстрого нахождения возможной записи.
Цепочки для разрешения коллизий: при хеш-коллизиях используется связанный список.

## 46. Сегментно-страничная виртуальная память.

Сегментно-страничная виртуальная память

Сегментно-страничная виртуальная память — это комбинированный подход, объединяющий сегментацию и страничную организацию памяти.

Сегментация: разделение виртуального адресного пространства на логические единицы (код, данные, стек).
Страничное преобразование: дальнейшее разделение каждого сегмента на страницы фиксированного размера.

ОС управляет информацией о сегментах через таблицу сегментов, а отображением страниц на физические кадры — через таблицы страниц.

Сегмент (S): номер сегмента, используемый для индексации в таблице сегментов.
Страница (P): номер страницы, используемый для индексации в таблице страниц внутри сегмента.
Смещение (O): смещение внутри страницы.

По номеру сегмента S запрашивается таблица сегментов, получается базовый адрес таблицы страниц для этого сегмента и предел его длины.
По номеру страницы P запрашивается таблица страниц, соответствующая сегменту, получается номер физического кадра.
Номер физического кадра + смещение внутри страницы O = физический адрес.

Преимущества:
*   Логическая организация: сохраняет естественную поддержку структуры программы, присущую сегментации.
*   Физическая эффективность: устраняет внешнюю фрагментацию благодаря страничной организации, повышая утилизацию памяти.
*   Защита и совместное использование:
    *   Защита на уровне сегментов: разные сегменты могут иметь разные права доступа.
    *   Совместное использование на уровне страниц: возможность совместного использования кода или данных с гранулярностью страницы.
*   Гибкость управления: поддерживает динамический размер сегментов, одновременно избегая фрагментации памяти.

Недостатки:
*   Сложность: требуется двухуровневая структура таблиц (таблица сегментов + таблицы страниц), накладные расходы на управление велики.
*   Производительность: одно преобразование адреса требует двух обращений к памяти (таблица сегментов → таблица страниц), требуется ускорение с помощью TLB.
*   Накладные расходы: таблицы сегментов и страниц занимают память.

## 47. Влияние размера страницы виртуальной памяти на ОС. Стратегии ОС по работе с виртуальной памятью.

Влияние размера страницы виртуальной памяти на ОС. Стратегии ОС по работе с виртуальной памятью

**Влияние размера страницы виртуальной памяти на ОС**

При разработке ОС необходимо определится с размером страницы. Важно учитывать:

– Размеры таблиц страниц.
– Внутреннюю фрагментацию.
– Количество page-fault при трансляции адреса.
– Скорость взаимодействия со вторичной памятью (и размер блока).
– Локальность данных (в многопоточных приложениях ниже).
– Количество промахов TLB, размер TLB, размер кэша L1, L2, L3, и др.

**Стратегии ОС по работе с виртуальной памятью**

Стратегии загрузки страниц

*   Подкачка по требованию — страницы загружаются с диска только при обращении к отсутствующей странице, экономит ввод-вывод, но высокая задержка при старте.
*   Предварительная выборка — прогнозирование и предварительная загрузка потенциально нужных страниц, уменьшает количество сбоев страниц, но возможны ошибочные предсказания.

Стратегии размещения страниц

*   Размещение с учётом NUMA — размещение страниц в локальном для ЦП узле памяти, к которому происходит доступ.

Стратегии очистки страниц

*   Очистка по требованию — запись изменённых страниц на диск только при необходимости освобождения кадров, задержка записи, может вызывать блокировки.
*   Предварительная очистка — периодическая запись изменённых страниц на диск, сглаживает нагрузку ввода-вывода, но возможны ненужные записи.

Стратегии управления многозадачностью

*   Свопинг всего процесса — при сильной нехватке памяти выгрузка всего процесса на диск.

Стратегии замещения страниц

Стратегии управления резидентной частью процессов

## 48. Стратегии замещения страниц ОС. Часовой Алгоритм. Управление резидентной частью процесса.

Стратегии замещения страниц ОС. Часовой алгоритм. Управление резидентной частью процесса

**Стратегии замещения страниц ОС**

Когда физической памяти недостаточно, ОС должна выбрать некоторые страницы для выгрузки на диск, чтобы освободить место для новых.

Следует выбрать страницы, к которым не будет обращений в течение максимально долгого времени в будущем, обычно основываясь на исторических шаблонах доступа.

*   Заблокированные страницы: страницы ядра, буферы ввода-вывода и т.д. не могут быть выгружены.
*   Разделяемые страницы: код общих библиотек используется несколькими процессами, выгрузка повлияет на все связанные процессы.

Оптимальная стратегия (OPT): выбор страниц, к которым не будет обращений в течение самого долгого времени в будущем, теоретически оптимальна, но не реализуема, используется только как эталон для сравнения производительности.

LRU (Least Recently Used / Наименее недавно использованная): выбор страниц, к которым дольше всего не было обращений, близка к OPT, но требует поддержки временных меток или стека доступа, аппаратные накладные расходы велики.

FIFO (First-In, First-Out / Первым пришёл — первым ушёл): выбор страниц, загруженных в память раньше всех, проста, но может выгружать часто используемые страницы, производительность низкая.

Часовой алгоритм: также известен как алгоритм второй попытки, является приближённой реализацией LRU с меньшими накладными расходами.

**Часовой Алгоритм**

> Физические кадры организуются в кольцевой список (подобно циферблату часов).
У каждой страницы есть бит доступа (бит R), который устанавливается в 1 аппаратно при обращении.

> Шаги алгоритма:
> 1. Указатель сканирует по часовой стрелке.
> 2. Если R=1, установить в 0 и пропустить.
> 3. Если R=0, выбрать эту страницу для выгрузки.
> 4. Указатель перемещается на следующий кадр.

На современных размерах памяти занимает много времени
Современная память велика (например, 16ГБ/4КБ ≈ 4,2 миллиона кадров), сканирование всех кадров занимает много времени, требуется оптимизация.

**Управление резидентной частью процесса**

Размер резидентной части:

*   При загрузке и выполнении процесса не обязательно держать все его страницы в памяти.
*   Чем меньше памяти занимает каждый процесс → тем больше процессов помещается в память.
*   Чем меньше страниц процесса в памяти → тем больше сбоев страниц.
*   После превышения N страниц дополнительное выделение памяти не приводит к значительному уменьшению количества сбоев страниц.
*   Стратегии управления: фиксированный размер и динамический размер.

Фиксированный размер: каждому процессу выделяется фиксированное количество страниц, просто, но не гибко.
Динамический размер: размер корректируется в зависимости от поведения процесса, эффективнее, но сложнее.

Локальное замещение — выбираются страницы для выгрузки только из процесса, вызвавшего сбой страницы; справедливо, процессы не влияют друг на друга, но: могут удерживаться ненужные страницы, утилизация памяти низкая.
Глобальное замещение — выбираются страницы для выгрузки из всех процессов (кроме заблокированных/разделяемых); утилизация памяти высокая, производительность системы лучше, но: может приводить к "голоданию" некоторых процессов.

## 49. Виды планирования процессов. Критерии краткосрочного планирования. Приоритеты.

Виды планирования процессов. Критерии краткосрочного планирования. Приоритеты

**Виды планирования процессов**

Долгосрочное планирование — решает, какие задания загрузить в память в качестве процессов.
Среднесрочное планирование — решает, какие процессы выгрузить/загрузить в память.
Краткосрочное планирование — решает, какой готовый процесс получит ЦП.

![Виды планирования процессов](Виды_планирования_процессов.png)

**Критерии краткосрочного планирования**

Пользовательские критерии, связанные с производительностью:

Оборотное время: общее время от подачи до завершения — минимизация среднего оборотного времени.
Время отклика: время от подачи запроса до первого ответа — минимизация времени отклика (интерактивные системы).
Сроки выполнения: крайний срок, к которому задача должна быть завершена — соблюдение временных ограничений реального времени.

Прочие пользовательские критерии:

Предсказуемость: время отклика остаётся стабильным при изменении нагрузки на систему.

Системные критерии, связанные с производительностью:
Пропускная способность: количество процессов, завершённых за единицу времени — максимизация пропускной способности.
Загрузка ЦП: процент времени, когда ЦП занят — поддержание высокой загрузки (но не 100%).

Прочие системные критерии:
Справедливость: все процессы получают разумную долю времени ЦП.
Соблюдение приоритетов: процессы с высоким приоритетом выполняются в первую очередь.
Балансировка ресурсов: поддержание сбалансированной нагрузки на все части системы.

**Приоритеты**

*   Процессам присваивается числовой приоритет — в разных ОС используются разные схемы назначения приоритетов.
*   Из очереди выбирается процесс с наивысшим приоритетом.
*   Если приоритеты процессов одинаковы, применяется другая стратегия.
*   Низкоприоритетный процесс может быть остановлен из-за нехватки ресурсов.
*   Приоритеты могут изменяться динамически.

## 50. Использование приоритетов.

Использование приоритетов

**Приоритеты**

*   Процессам присваивается числовой приоритет — в разных ОС используются разные схемы назначения приоритетов.
*   Из очереди выбирается процесс с наивысшим приоритетом.
*   Если приоритеты процессов одинаковы, применяется другая стратегия.
*   Низкоприоритетный процесс может быть остановлен из-за нехватки ресурсов.
*   Приоритеты могут изменяться динамически.

## 51. Стратегии планирования FCFS, RR, SPN, SRT, HRRN, Feedback.

Стратегии планирования: FCFS, RR, SPN, SRT, HRRN, Feedback.

**FCFS (First-Come, First-Served / Первым пришёл — первым обслужен)**

Непереключаемый: как только процесс начинает выполняться, он не освобождает ЦП до завершения или блокировки.
На основе порядка прибытия: очередь готовых процессов упорядочена по времени прибытия, самый ранний прибывший процесс выполняется первым.

**RR (Round Robin / Циклическое планирование)**

Переключаемый: каждому процессу выделяется фиксированный квант времени (например, 10-100 мс), по истечении которого он помещается в конец очереди готовых процессов.
Циклическое выполнение: все готовые процессы выполняются по очереди.

**SPN (Shortest Process Next / Кратчайший процесс следующим)**

Непереключаемый: выбирается процесс с наименьшим общим ожидаемым временем выполнения.
Требуется прогнозирование времени выполнения: на основе истории или информации от пользователя.

**SRT (Shortest Remaining Time / Кратчайшее оставшееся время)**

Переключаемый: при появлении нового процесса, если его оставшееся время выполнения меньше, чем у текущего процесса, происходит переключение.
Динамическое обновление: требуется постоянное отслеживание оставшегося времени выполнения каждого процесса.

**HRRN (Highest Response Ratio Next / Наибольшее отношение ответа следующим)**

Коэффициент ответа:
R = (w + s) / s

где:
w = время ожидания,
s = ожидаемое время выполнения

Выбирается процесс с наибольшим значением R: балансирует время ожидания и время выполнения.

**Feedback (Обратная связь / Многоуровневые очереди с обратной связью)**

Многоуровневые очереди: процессы группируются по приоритетам в несколько очередей.
Динамическое понижение: процесс, израсходовавший свой квант времени, понижается в приоритете (перемещается в очередь более низкого приоритета).
Динамическое повышение: процесс, разблокировавшийся (например, после ввода-вывода) и снова ставший готовым, может быть повышен в приоритете (перемещён в очередь более высокого приоритета).
Переменный квант времени: разным очередям приоритетов могут быть назначены разные кванты времени (обычно в очередях более высокого приоритета квант короче).

## 52. Feedback планировщик и классы планирования ОС UNIX SVR4.

Планировщик с обратной связью и классы планирования в ОС UNIX SVR4.

**Feedback планировщик (Планировщик с обратной связью)**

Обратная связь — снижение приоритета в зависимости от длительности выполнения.
Если программа блокируется или вытесняется — то результат обратной связи.

Многоуровневые очереди с обратной связью (Multilevel Feedback Queue, MLFQ): система поддерживает несколько очередей с разными приоритетами, процессы перемещаются между ними в зависимости от своего поведения.

**Классы планирования**

UNIX SVR4 делит процессы на несколько классов планирования (Scheduling Classes), каждый со своей стратегией планирования и диапазоном приоритетов.

*   TimeSharing — разделение времени (Обратная связь)
*   InterActive — интерактивный (повышение приоритета активному приложению)
*   Fixed, System, RealTime — классы с фиксированными приоритетами
*   Fair Share Scheduler — справедливый планировщик
*   Отдельные приоритеты для Interrupt threads
*   Учёт аффинити для NUMA

## 53. Справедливое планирование.

Справедливое планирование

**Справедливое планирование**

*   На основе долей (Share-based): каждому пользователю, группе или проекту выделяется определённая доля ЦП (CPU share), например, в процентах или весах.
*   Цель: обеспечить, чтобы каждая сущность получала время ЦП, пропорциональное её доле, независимо от количества её процессов или их поведения.
*   Системная справедливость: учитывает все ЦП (многоядерные/многопроцессорные системы), глобальное распределение вычислительных ресурсов.

## 54. Планирование в многопроцессорных системах. Типы многопроцессорных систем с точки зрения организации планирования. Гранулярность и проектирование планировщиков процессов и потоков для многопроцессорных систем.

Планирование в многопроцессорных системах. Типы многопроцессорных систем с точки зрения организации планирования. Гранулярность и проектирование планировщиков процессов и потоков для многопроцессорных систем

**Типы многопроцессорных систем**

Слабосвязанные (распределенные, кластеры)
*   Каждый узел имеет независимую подсистему памяти и ввода-вывода, соединён сетью.
*   Распределение разделяемых данных и результатов.
*   Распределение задач между системами.

Функционально-специализированные
*   Процессор отвечает за распределение и координацию задач.
*   Подчинённые процессоры выполняют вычисления.

Сильносвязанные процессоры
*   Все ЦП имеют доступ к одной и той же физической памяти.
*   Обычно управляются единой операционной системой.

**Гранулярность и проектирование планировщиков процессов и потоков для многопроцессорных систем**

Гранулярность синхронизации — частота синхронизации между процессами в системе
Гранулярность синхронизации относится к частоте синхронизации между процессами в системе.

Fine (Мелкая) — параллелизм на уровне отдельных машинных инструкций — < 20 инструкций.
Medium (Средняя) — параллелизм на уровне отдельных приложений — 20-200 инструкций.
Coarse (Крупная) — параллелизм на уровне независимых процессов — 2000-1,000,000 инструкций.
Independent (Независимая) — без синхронизации, полностью независимые процессы — синхронизация отсутствует.

Назначение процессов процессорам

*   Статическое — каждому процессу назначается свой процессор.
*   Динамическое — все процессы используют общую очередь.
*   Динамическая балансировка нагрузки — периодическая миграция процессов для балансировки нагрузки.

Даже при привязке каждого ЦП к процессу, может потребоваться выполнение нескольких потоков на одном ЦП (многозадачность).

В многопроцессорных системах влияние алгоритма выбора планирования может ослабевать, так как несколько ЦП могут выполнять процессы параллельно.
Однако балансировка нагрузки, аффинити, накладные расходы на синхронизацию становятся более критичными факторами.

## 55. ОС реального времени и планировщики. Deadline-планирование.

Операционные системы реального времени и планировщики. Deadline-планирование.

**Жёсткое реальное время (Hard Realtime):** пропуск дедлайна приводит к катастрофическим последствиям — управление полётом, кардиостимуляторы.
**Мягкое реальное время (Soft Realtime):** пропуск дедлайна приводит к снижению качества обслуживания, но допустим — видеопоток, обработка звуковых эффектов.

Требования:
*   Детерминизм: операции должны завершаться в предопределённые временные интервалы, обычно измеряется задержкой прерывания (время от возникновения прерывания до начала его обработки).
*   Отзывчивость: скорость реакции системы на внешние события, включает время обработки прерываний и время переключения задач.
*   Управление пользователя: позволяет пользователю указывать приоритеты задач, дедлайны, стратегии планирования и т.д.
*   Высокая надёжность: требования к отказоустойчивости и стабильности выше, чем у универсальных ОС.
*   Смягчение ошибок (fault softness): при возникновении ошибок не должно происходить краха системы (например, дамп ядра), следует переходить в режим пониженной функциональности.

Планировщик: строгое использование вытесняющего планирования с приоритетами и ограниченными, минимальными задержками.

**Deadline-планирование (Планирование по срокам)**

Ключевая идея: задача должна быть завершена (или начата) до установленного срока (дедлайна).
Независимость от ресурсов: дедлайн должен стараться соблюдаться даже при конфликтах ресурсов, сбоях или временном дефиците.

*   **Earliest Deadline First (EDF) / Наименьший срок исполнения:** Динамический приоритет. Выбирается задача с самым ранним сроком завершения.
*   **Least Laxity First (LLF) / Наименьшее время запаздывания:** Динамический приоритет. Выбирается задача с наименьшим временем запаздывания (laxity = дедлайн — оставшееся время обработки — текущее время).
*   **Rate-Monotonic Scheduling (RMS) / Монотонное по частоте:** Статический приоритет. Чем короче период периодической задачи, тем выше её приоритет.
*   **Deadline-Monotonic Scheduling (DMS) / Монотонное по срокам:** Статический приоритет. Чем короче относительный дедлайн периодической задачи (время от старта до завершения), тем выше её приоритет.

## 56. Проблема инверсии приоритетов, типы инверсии и способы решения в планировщике.

Проблема инверсии приоритетов, типы инверсии и способы решения в планировщике.

**Инверсия приоритетов** — это явление, когда задача с высоким приоритетом блокируется, ожидая освобождения разделяемого ресурса, занятого задачей с низким приоритетом, и при этом может быть вытеснена задачей со средним приоритетом, что приводит к длительной блокировке задачи с высоким приоритетом.

Суть проблемы:
Из-за взаимного исключения доступа к разделяемым ресурсам (например, блокировкам, семафорам), когда ресурс удерживается задачей с низким приоритетом, задача с высоким приоритетом вынуждена ждать. Если в этот момент появляется готовая задача со средним приоритетом, она может вытеснить задачу с низким приоритетом, тем самым косвенно блокируя задачу с высоким приоритетом на более длительное время, что нарушает ожидаемое поведение системы с приоритетами.

Типы инверсии:
*   **Ограниченная инверсия приоритетов (Bounded Priority Inversion):** Длительность инверсии ограничена (например, временем удержания ресурса низкоприоритетной задачей).
*   **Неограниченная инверсия приоритетов (Unbounded Priority Inversion):** Длительность инверсии может неограниченно увеличиваться из-за вмешательства других задач среднего приоритета (как в примере с миссией на Марс).
*   **Цепочка блокировок (Blocking Chain):** Процесс блокировки распространяется на несколько задач и ресурсов.

**Способы решения:**
– **Наследование приоритета (Priority Inheritance):** Низкоприоритетная задача, удерживающая ресурс, необходимый высокоприоритетной, временно получает (наследует) приоритет этой высокоприоритетной задачи. Это предотвращает её вытеснение задачами среднего приоритета и ограничивает время блокировки высокоприоритетной задачи.
– **Протокол немедленного приоритета (Immediate Priority Ceiling Protocol) / Протокол верхнего предела приоритета (Priority Ceiling Protocol):** Каждому ресурсу назначается "потолок приоритета" — приоритет, равный наивысшему приоритету среди всех задач, которые могут его запросить. Задача, захватывающая ресурс, немедленно повышает свой приоритет до этого потолка. Это предотвращает не только инверсию, но и взаимоблокировки.

# Ввод-выводы

## 57. Ввод-вывод. Современные устройства и скорости обмена, развитие способов ввода-вывода, логическая структура ввода-вывода.

Ввод-вывод. Современные устройства и скорости обмена, развитие способов ввода-вывода, логическая структура ввода-вывода.

Устройства:
*   Пользовательские устройства.
*   Внутренние устройства.
*   Устройства связи.

Основные характеристики: скорость, назначение, сложность управления, единица передачи, представление данных и условия возникновения ошибок.

*   **Программируемый ввод-вывод (PIO):** ЦП напрямую управляет устройством или контроллером через шину и регистры.
*   **Ввод-вывод с прерываниями:** Контроллер поддерживает прерывания, что позволяет избежать ожидания ЦП.
*   **Прямой доступ к памяти (DMA):** Контроллер оснащён регистрами и счётчиком и может напрямую передавать данные из буфера в память.
*   **Каналы/Процессоры ввода-вывода:** Контроллер становится независимым вычислительным модулем со своим процессором и системой команд, полностью управляющим вводом-выводом для группы устройств.

![логическая структура ввода-вывода](логическая_структура_ввода-вывода.png)

## 58. Буферизация ввода-вывода. Ввод-вывод в UNIX SVR4.

Буферизация ввода-вывода. Ввод-вывод в UNIX SVR4.

I — время ввода-вывода.
C — время обработки.
M — время передачи.

*   **Без буферизации:** Прямая передача, неэффективна.
*   **Одиночная буферизация:** Один буфер, операции ввода-вывода и обработки чередуются.
*   **Двойная буферизация:** Два буфера, один для ввода-вывода, другой для обработки, повышает параллелизм.
*   **Кольцевая буферизация:** Несколько буферов, организованных в кольцевую очередь, подходит для непрерывных потоков данных.

## 59. Диски и дисковое планирование.

Диски и дисковое планирование.

**HDD (Жёсткий диск):** Зависит от механических частей: быстро вращающиеся магнитные пластины и перемещающиеся головки, чтение/запись данных осуществляется электромагнитной индукцией.
**SSD (Твердотельный накопитель):** Не содержит движущихся частей. Использует флеш-память (NAND), доступ к данным осуществляется через электронные схемы.

![Формула времени доступа](Формула_времени_доступа.png)

**Дисковое планирование (Disk Scheduling)**

*   **FIFO:** Справедливо, но неэффективно.
*   **PRI:** На основе приоритета процесса.
*   **LIFO:** Использует локальность данных.
*   **SSTF (Shortest Seek Time First / Кратчайшее время поиска первым):** Обслуживает запрос с ближайшей к головке дорожки.
*   **SCAN (Алгоритм лифта):** Головка движется от одного края диска к другому, обслуживая запросы по пути, затем разворачивается.
*   **C-SCAN (Циклический SCAN):** Одностороннее сканирование (например, только наружу), быстрый возврат в начало.
*   **N-step-SCAN:** Разделение очереди на подочереди длиной N.
*   **FSCAN:** Использование двух подочередей, которые обрабатываются поочерёдно.

## 60. Концепции RAID.

Концепции RAID.

**RAID (Избыточный массив независимых дисков)** — это технология логического объединения нескольких физических дисков в один единый логический блок для повышения производительности и/или надёжности.

Основные идеи:
*   Распределение данных по нескольким дискам.
*   Использование избыточной ёмкости для хранения контрольной информации.
*   Поддержка параллельного ввода-вывода.
*   Необходимость учитывать производительность адаптеров, шин и шин ввода-вывода (например, PCIe).

## 61. RAID-0, 1, 10, 0+1.

RAID 0, 1, 10, 0+1.

**RAID 0 — Объединение / Чередование (Striping)**
Очень быстрый, но ненадёжный.
*Объединяет несколько дисков в один логический том большего объёма.*

Две формы:
*   **Конкатенация (Concatenation):** Простое "склеивание" дисков, возможно разных размеров. Данные последовательно заполняют один диск, затем следующий.
*   **Чередование (Striping):** Требует диски одинакового размера (или работает по наименьшему). Данные разбиваются на блоки фиксированного размера (Stripe Unit / Элемент полосы), которые поочерёдно записываются на разные диски.

**Элемент полосы (Stripe Unit):** Базовая единица, на которую разбиваются данные. Несколько элементов полосы образуют размер полосы (Stripe Size), обычно от 16 КБ до 128 КБ. Конкретный размер настраивается при создании RAID.

Особенности:
*   Низкая надёжность: нет избыточности. Повреждение любого диска ведёт к потере всех данных.
*   Высокая пропускная способность: данные читаются/пишутся параллельно, общая пропускная способность близка к сумме пропускных способностей всех дисков.
*   Высокая скорость обработки запросов: особенно подходит для последовательного чтения/записи больших файлов.

**RAID 1 — Зеркалирование (Mirroring)**
Надёжный, но скорость чтения ограничена.
Комбинирует диски путём дублирования блоков данных. Каждый блок данных записывается на два (или более) диска, образуя зеркало.

Двойная (или более) избыточность: данные имеют полную копию.

Особенности (для базового RAID 1):
*   Высокая надёжность: допускает отказ как минимум одного диска (зависит от количества зеркал).
*   Удвоенная производительность чтения: данные можно читать с любого из зеркальных дисков.
*   Производительность записи как у одного диска: данные должны быть записаны на все зеркальные диски, поэтому пропускная способность записи ограничена скоростью одного диска.

**Тонкие различия между RAID 10 и RAID 0+1**

**RAID 10 (RAID 1+0):**
*   Сначала зеркалирование, потом чередование. Диски объединяются парами в зеркала (RAID 1), затем несколько таких зеркальных пар объединяются в чередующийся массив (RAID 0).
*   Лучшая отказоустойчивость: данные в безопасности, пока в каждой зеркальной паре не выйдут из строя оба диска одновременно. Может выдержать отказ нескольких дисков, если они находятся в разных парах.

**RAID 0+1:**
*   Сначала чередование, потом зеркалирование. Сначала все диски объединяются в один большой чередующийся набор (RAID 0), затем весь этот набор полностью зеркалируется на другую группу дисков.
*   Слабая отказоустойчивость: если в чередующемся наборе выходит из строя любой диск, весь набор становится неработоспособным. В этот момент система полностью зависит от зеркальной группы. Обычно может выдержать только одиночные несвязанные сбои в одной из групп, в зависимости от реализации.

## 62. RAID 4,5,6. Аппаратные дисковые массивы.

RAID 4, 5, 6. Аппаратные дисковые массивы.

**RAID 4:** Предоставляет отказоустойчивость за счёт выделенного диска для контроля чётности (parity disk). Этот диск становится серьёзным узким местом при операциях записи, поэтому на практике используется редко.
**RAID 5:** Распределяет контрольную информацию (блоки чётности) равномерно по всем дискам массива, а не использует выделенный диск. Это основное улучшение по сравнению с RAID 4.
**RAID 6:** Использует двойную контрольную информацию, может выдержать одновременный отказ двух дисков. Достигается это ценой более низкой производительности записи и ещё меньшей полезной ёмкости.

**Аппаратные дисковые массивы**

*   Сложная архитектура: включают специализированный RAID-процессор, большой кэш, резервное питание и т.д.
*   Очень высокая производительность: оптимизированы пути ввода-вывода, обеспечивают низкие задержки и высокую пропускную способность.
*   Высокая отказоустойчивость: оснащены горячей заменой дисков, резервными блоками питания и вентиляторами, аккумуляторным резервом кэша (BBWC/FBWC) и др.
*   Высокая стоимость: дороги по сравнению с программным RAID или простыми контроллерами.
*   Большая ёмкость хранения: поддерживают подключение большого количества дисков.
*   Удалённое управление: предоставляют веб-интерфейс (HTTP) или интерфейс командной строки (SSH) для конфигурации и мониторинга.

## 63. Файловый ввод-вывод, основные определения. Задачи ОС по управлению файлами. Совместное использование файлов.

Файловый ввод-вывод, основные определения. Задачи ОС по управлению файлами. Совместное использование файлов.

**Файл** определяется как набор данных со следующими свойствами:
1.  Имеет структуру: файл может обладать сложной внутренней структурой. Один файл может даже содержать несколько различных структур.
2.  Долговременное существование: файлы хранятся на энергонезависимых носителях (например, дисках) и сохраняются после завершения создавших их процессов.
3.  Может использоваться несколькими процессами совместно: файл может быть доступен и использоваться одним или несколькими процессами в системе.

**Задачи ОС по управлению файлами**

Базовые файловые операции (предоставляемые ОС) включают:
*   Основные операции: создание, удаление, открытие, закрытие, чтение, запись, позиционирование.
*   Управляющие операции: получение или установка атрибутов файла (метаданных).
*   Операции синхронизации и блокировки: управление конкурентным доступом нескольких процессов к файлу.

**Совместное использование файлов (Разрешения)**

Механизмы совместного использования файлов управляются совместно владельцем файла и операционной системой.

Уровни разрешений (от низкого к высокому):
*   Нет: другой пользователь даже не знает о существовании файла.
*   Знание: пользователь знает о существовании файла, но должен запросить разрешение у владельца для доступа.
*   Выполнение: пользователь может загрузить и запустить файл (если это программа).
*   Чтение: пользователь может просмотреть содержимое файла.
*   Добавление: пользователь может добавить данные в конец файла.
*   Изменение: пользователь может изменить содержимое файла.
*   Удаление: пользователь может удалить файл.
*   Изменение разрешений: пользователь может назначать права доступа другим (это обычно прерогатива владельца).

Пример: `chmod 777`

Объекты назначения разрешений:
*   Конкретный пользователь.
*   Список пользователей или группа пользователей.
*   Все пользователи.

Управление конкурентным доступом (блокировки):
*   Чтобы предотвратить одновременное изменение файла несколькими процессами, что может привести к несогласованности данных, ОС предоставляет механизмы блокировок:
*   Блокировка файла: блокировка всего файла.
*   Блокировка записей: блокировка только определённых записей в файле (более тонкий контроль).

## 64. Управление файлами в UNIX SVR4.

Управление файлами в UNIX SVR4.

UNIX SVR4 абстрагирует почти все ресурсы как "файлы", различая их по полю типа в inode:

*   **Обычные файлы:** Хранят пользовательские данные.
*   **Директории:** Файлы каталогов, по сути — специальные файлы, содержимое которых представляет собой таблицу соответствия имён файлов в этом каталоге номерам inode.
*   **Блочные устройства:** Файлы блочных устройств (например, HDD, SSD), предоставляют интерфейс произвольного доступа к блокам.
*   **Символьные устройства:** Файлы символьных устройств (например, терминалы, принтеры), предоставляют интерфейс последовательного доступа к потоку символов.
*   **Именованные каналы (FIFO):** Файлы именованных каналов, используются для межпроцессного взаимодействия.
*   **Жёсткие ссылки:** Несколько записей в каталогах указывают на один и тот же inode, являются разными именами одного и того же файла.
*   **Символические ссылки:** Специальный тип файлов, содержимое которых представляет собой строку пути к другому файлу или каталогу.

## 65. Каталоги файлов. Элементы каталога, операции ОС.

Каталоги файлов. Элементы каталога, операции ОС.

**Содержимое записи о файле (в каталоге или inode):**

1.  Базовая информация:
    *   **Имя файла.**
    *   **Тип файла:** например, двоичный, текстовый и т.д.
    *   **Организация файла:** способ организации внутренней структуры файла.
2.  Адресная информация:
    *   **Том:** идентификатор тома, указывающий на физическое устройство хранения.
    *   **Начальный адрес:** номер первого блока данных файла.
    *   **Занимаемый размер и зарезервированный размер:**
        *   **Занимаемый размер:** фактическое количество байт в файле.
        *   **Зарезервированный размер:** максимальное количество байт, предварительно выделенное для файла (может быть больше фактического размера).
3.  Информация управления доступом:
    *   **Владелец:** пользователь, который имеет право управлять файлом.
    *   **Разрешенные действия:** права доступа, такие как чтение, запись, выполнение, поиск и т.д.
4.  Информация об использовании:
    *   **Создатель и дата создания:** пользователь, создавший файл (может отличаться от текущего владельца), и дата создания.
    *   **Дата последнего чтения и последний пользователь, прочитавший файл.**
    *   **Дата последнего изменения и последний пользователь, изменивший файл.**
    *   **Дата последней резервной копии на другом устройстве.**
    *   **Текущее использование:** информация о текущих операциях с файлом (например, каким процессом и в каком режиме открыт).

**Элементы каталога, операции ОС**

1.  Представление каталога в памяти:
    *   Каталог может быть полностью или частично загружен в основную память для ускорения доступа.
    *   Простейшая структура: список записей фиксированной длины.
2.  Основные операции с каталогами:
    *   **Поиск файловых записей:** поиск записи в каталоге по имени файла.
    *   **Создание и удаление записей о файле:** создание нового файла (добавление записи) или удаление файла (удаление записи).
    *   **Получение списка записей:** перечисление содержимого каталога.
    *   **Обновление каталога, изменение записи:** обновление информации в каталоге, например, переименование файла, изменение прав доступа или других атрибутов.
3.  Распространённые организационные структуры каталогов:
    *   **Дерево:** древовидная структура, каждый файл имеет уникальный путь (наиболее распространённая, например, в UNIX, Windows).
    *   **Связанный граф:** структура в виде связанного графа, позволяющая более сложные связи (например, символические ссылки, образующие граф).
4.  Способы именования:
    *   **Имя файла:** только имя самого файла (например, `report.txt`).
    *   **Полное имя, включающее путь от корня:** абсолютный путь (например, `/home/user/report.txt`).
    *   **Имя относительно текущего каталога:** относительный путь (например, `./docs/report.txt` или `../data.txt`).

## 66. Размещение записей и файлов в блоках данных. Сложность и типы организации размещения.

Размещение записей и файлов в блоках данных. Сложность и типы организации размещения.

**Запись:**
*   Это логическая единица доступа в структурированном файле.
*   Например: строка в таблице базы данных или полная запись информации о студенте.
*   Пользовательские программы обычно обрабатывают данные именно записями.

**Блок:**
*   Это физическая единица ввода-вывода для операционной системы.
*   Данные всегда передаются между памятью и диском целыми блоками.
*   Размер блока является фундаментальным параметром, определяемым при форматировании файловой системы (например, 4 КБ).

**Ключевое противоречие:** Пользователь хочет обращаться к данным записями (логическая единица), но аппаратное обеспечение и ОС передают данные блоками (физическая единица). Поэтому то, как организовать записи в блоки, является одной из ключевых проблем проектирования файловых систем.

*   Большой блок → за одну передачу читается много записей, но могут передаваться ненужные данные.
*   Маленький блок → низкая эффективность передачи, но подходит для случайного доступа.

**Типы размещения записей в блоках:**
*   **Фиксированная упаковка (Fixed Spanning):** Записи фиксированной длины, размещаются в блоке последовательно.
*   **Упаковка переменной длины с указателями (Variable-Length Unspanned):** Записи переменной длины, связаны между собой указателями (ссылками) внутри блока или между блоками.
*   **Упаковка переменной длины без указателей (Variable-Length Spanned):** Записи переменной длины размещаются в блоке последовательно, без явных указателей. Если запись не помещается в конец блока, она переносится в начало следующего.

**Вывод:** Способ организации записей в блоках влияет на эффективность доступа к файлам и использование хранилища, и должен выбираться в зависимости от шаблонов доступа.

## 67. Непрерывное размещение файлов (на примере ОС RT-11).

Непрерывное размещение файлов (на примере ОС RT-11).

RT-11 использовала непрерывное (последовательное) выделение:
*   Файл занимает непрерывную последовательность физических блоков на диске.
*   Запись в каталоге содержит номер начального блока и размер файла.
*   Особенности: малая внутренняя фрагментация, но большая внешняя фрагментация, требуется периодическое уплотнение файловой системы (дефрагментация).

## 68. Цепочечное размещение файлов (на примере DOS FAT).

Цепочечное размещение файлов (на примере DOS FAT).

DOS FAT использовала связное (цепочное) выделение:
*   Данные файла разбросаны по диску, как звенья цепи. Каждый блок данных содержит адрес (номер) следующего блока в цепи.
*   Файл хранится в единицах, называемых **кластерами**, а не в отдельных секторах.
*   Запись в каталоге содержит номер начального кластера.
*   Размер кластера может варьироваться (от 512 Б до 32 КБ).

**Преимущества:**
*   Высокое использование пространства: можно использовать любые свободные кластеры, нет внешней фрагментации (в классическом понимании, хотя цепочка может быть разорвана).
*   Файл может динамически расти: в конец цепочки всегда можно добавить новый кластер.
*   Простая реализация: FAT-таблица — это просто большой массив.

**Недостатки:**
*   Очень медленный произвольный доступ: чтобы найти 1000-й байт файла, нужно пройти по цепочке от начала.
*   Проблемы надёжности: повреждение FAT-таблицы или разрыв цепи → потеря файла.
*   Низкая эффективность доступа: головки диска должны прыгать по разным местам.

**Вывод:** Связное выделение гибко поддерживает динамический рост файлов, но обеспечивает низкую эффективность доступа и может приводить к фрагментации (разрыву цепочек).

## 69. Индексированное размещение (на примере файловой системы UNIX UFS).

Индексированное размещение (на примере файловой системы UNIX UFS).

*   Каждый файл имеет структуру, называемую **inode (индексный дескриптор)**. Inode содержит такую информацию, как размер файла, права доступа, и, что важно, **адреса блоков данных**. Обращаясь к inode, можно найти расположение всех блоков данных файла.

**Макет файловой системы UFS:**
*   **Суперблок:** содержит общую информацию о файловой системе (размер, количество блоков и т.д.).
*   **Группы цилиндров:** диск делится на несколько групп, каждая из которых имеет свою таблицу inode и битовую карту свободных блоков. Блоки данных стараются размещать как можно ближе к своему inode, чтобы уменьшить перемещение головок.

**Механизм индексирования в UFS (на примере классической схемы):**
*   **Небольшие файлы:** inode содержит несколько (например, 12) прямых указателей на блоки данных.
*   **Большие файлы:**
    *   **Одинарная косвенная адресация:** inode содержит указатель на блок-индекс (косвенный блок). Этот блок содержит указатели на блоки данных.
    *   **Двойная косвенная адресация:** inode → блок двойной косвенности → блоки косвенности → блоки данных.
    *   **Тройная косвенная адресация:** и т.д. (поддерживает огромные файлы).

**Преимущества:**
*   Быстрый произвольный доступ: обратившись к inode, можно напрямую вычислить расположение нужного блока (или через 1-2 уровня косвенности).
*   Нет внешней фрагментации: блоки файла могут быть разбросаны где угодно на диске, все свободные блоки доступны.
*   Файлы могут динамически менять размер: можно просто добавлять или удалять блоки, обновляя inode.

**Недостатки:**
*   Требуется дополнительное пространство: хранение таблиц inode и косвенных блоков занимает место на диске.
*   Для очень больших файлов доступ немного медленнее: если файл огромен, может потребоваться несколько чтений косвенных блоков, чтобы найти нужный блок данных.

**Вывод:** UFS использует inode для создания "индексной карты" для каждого файла. Это обеспечивает быстрый поиск данных, отсутствие фрагментации и возможность динамического изменения размера, что является фундаментальным дизайном современных файловых систем.