# Тестирование

### 52. Основные понятия тестирования. Цели тестирования.  

#### **术语定义**
- **Mistake（人为错误）**：指人类在工作中产生的失误（如需求分析时的理解偏差、编码时的手误等）。
- **Fault（缺陷/瑕疵）**：程序中的逻辑错误（如算法步骤错误、代码逻辑漏洞）。
- **Failure（故障/失效）**：系统外部表现出的异常（如程序崩溃、功能无响应，是缺陷的外在体现）。
- **Error（错误）**：因系统故障导致任务无法完成（如数据库连接失败导致数据无法读取）。
- **Bug（漏洞）**：泛指程序中的任何不正确行为（非官方术语，使用更通俗）。

#### **重要补充：环境对故障的影响**
程序运行环境可能显著引发故障。就像在家庭生活中，你可能对伴侣百般呵护，但一旦面对岳母或婆婆，就会遭遇现实的“暴击”——环境的变化（如硬件配置、网络条件、兼容性问题）可能让隐藏的缺陷暴露为故障。

#### **测试的核心目标**  
1. **发现缺陷**：通过测试找出程序中的错误。
2. **提升质量信心**：验证软件质量，增强团队与用户对产品的信任。
3. **提供决策依据**：通过测试数据（如缺陷分布、覆盖率）辅助项目决策（如是否发布、是否需要重构）。
4. **预防缺陷**：通过测试反馈优化开发流程，减少未来缺陷的产生。


测试的目的:
提高用户对程序在所有必要情况下都能正确运行这一事实的可接受信任水平。

也就是说，测试人员的任务是向用户证明，开发人员利用所有合理的手段，展示程序中不存在（或不存在重大）缺陷。

正确行为是指程序应符合对它提出的要求。通常，尤其是在需求不明确的情况下，存在关于正确行为的隐含规则，例如行业标准、惯例，这些在程序运行环境中存在。存在许多关于程序正确行为的信息来源。

---

### 53. Понятие полного тестового покрытия и его достижимости. Пример.

**测试覆盖**这一概念涵盖了**应用程序代码被测试用例覆盖的程度**，这些测试用例能够发现现有和潜在的缺陷。完全的测试覆盖意味着要测试代码中所有可能的执行路径的所有可能变体。完全的测试覆盖即便能够实现，其目标也非常不切实际。  

以两个数相乘的函数为例。假设两个乘数的取值范围都是0到2^32 - 1，那么完全覆盖的测试用例数量将达到2^64个。考虑到现代计算机每纳秒大约能执行2^10次运算，且2^10近似等于10^3，那么在3Гц（千兆赫兹）的处理器上对该函数进行测试将耗时约181.5年。

\[
\frac{2^{32} \cdot 2^{32}}{3 \cdot 10^9} = \frac{2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^{34}}{3 \cdot 10^9} \approx \frac{2^{34}}{3 \cdot 10^9} \approx \frac{5723784000 [c]}{365 \cdot 24 \cdot 60 \cdot 60} = 181,5 [лет]
\]  

**组织测试最简单的方法** --- **使用表格**，其中每一行包含两个乘数以及作为标准的结果。在上述示例中，存储所有可能的正确结果将需要的空间，相当于存储大约这么多字符和数字。

需要注意的是，在任何情况下，都不能为构建这样的表格使用实际乘法的结果，因为**标准结果本身可能存在错误**，无论是由程序还是人员造成的。

显然，在实际程序中，数据的可变性会比示例中更大。  

---

### 54. Статическое и динамическое тестирование.

**静态（评审）**
- 不涉及代码执行。
- 可人工进行，也可自动化开展。
- 是非正式的、大致的检查、审查。

静态测试是与启动为软件编写的测试集无关的测试。它涵盖了对文档、代码的非执行性评审和检查方法。在开发早期阶段代码的静态测试尚未存在时，静态测试有助于更早发现缺陷，节省时间和资源。静态测试需要检查规范、架构原则、需求等。在开发生命周期中，有一种观点认为，随着从一个开发阶段过渡到另一个阶段，修复已发现缺陷的成本会呈指数级（约 10 倍）增长。

**动态**
- 启动模块、模块组、整个系统。 
- 在首段代码编写后进行（在测试驱动开发（TDD）中——有时会在编写代码前！） 

动态测试需要已编写的代码和架构（会执行模块、模块组或整个系统的编译与启动）。 

一段时间以来，还推广了**测试驱动开发（TDD）方法**，在这种方法中，测试是在编写代码之前创建的，根据这些测试进一步确定代码的功能。在开发过程中，编写测试，这些测试最初执行时会失败。随着代码的开发，修正并重新运行测试，直到实现“绿色”（所有测试都成功执行 ）。开发完成时，所有测试都应成功执行。

---

### 55. Автоматизация тестов и ручное тестирование. 测试自动化和手动测试。

- 回归测试
- 重复执行测试场景
- 验收测试
- 减少人工劳动？
- 检查同一应用在不同环境中的表现

自动化测试是一种积极的现象，但**手动测试往往仍是必要且实际的**，尤其是在简单任务中——编写复杂程序、制定测试流程本身就很复杂，而在功能变更时复用测试场景则轻松许多。

回归测试是一种特殊的测试类型，核心逻辑是：**若程序功能变更，需重新执行整套测试，以此排查变更是否破坏原有功能，避免因修改部分代码引发全局故障**。

要实现测试自动化并开展回归测试，需保障测试场景可稳定复现（软件内部行为应具备一致性，相同输入需产出相同输出）。

检查同一应用在不同环境中的表现（即**兼容性测试**）也很关键。因不同环境重复执行测试的需求客观存在，相比编写复杂程序、整理庞大功能测试文档，复用这类测试的成本要低得多。

---

### 56. Источники данных для тестирования. Роли и деятельности в тестировании.

**软件描述——黑盒方法**：
- 规格、需求、设计
- 启动并将结果与标准进行比较
**源代码——白盒方法**：
- 转移、断言、条件
- 分析路径、结构
**经验**
**模型：UML（统一建模语言）**

在**黑盒方法**中，假设不知道软件的内部内容。工作的进行方式是，基于规范创建测试。测试向程序提供初始数据，并将结果与预期标准进行比较。测试数据的来源是规范、需求和设计。

在**白盒方法**中，有可能研究源代码。除了能够验证程序是否正确运行之外，该方法还可以使用数学方法计算最大测试覆盖率。为此，会为应用程序构建一个图，其中代码的各个部分表示为图的节点，分支和循环表示为转移。之后确定所谓的程序的圈复杂度，它决定了为了完全检查程序通常需要执行的测试用例的大致数量。会选择具体的测试用例，以便覆盖所得到图的所有路径。

通常，这些测试方法不能被绝对地归为某一特定类别。每种方法在其范围内都可能是有用的。

**测试数据的额外来源是开发人员的经验**。经验能够以典型方法解决标准情况，从而最大限度地降低出错的可能性。

**测试数据的来源还可以是模型**，包括UML图及其解释。从UML图中选择主要和替代路径，然后为这些路径选择用于测试的具体数据。 


- 测试设计：
  - 基于正式标准
  - 基于领域知识、经验和资质认证
- 测试自动化：
  - 了解工具、脚本
- 测试执行：
  - 对资质无特殊要求
- 结果分析：
  - 领域知识

测试中的角色和活动可分为几大类别：

**测试设计**：设计测试的人员，资质需足够高，要深入了解领域、所测试应用的特点，掌握有效的测试方法，同时具备一定的数学知识、编程技能和系统测试知识。

**测试自动化**：通常由专注于开发测试脚本或程序的程序员负责。公认的是，单元测试与程序代码联系最紧密，对编程、架构知识以及不同应用部分的实现细节要求极高。

**直接执行测试**不需要人员具备高资质，但该人员需了解测试基础设施、使用测试环境的原则，以及具备基本的计算机操作技能。

对于**结果分析**，既需要领域知识，也需要技术知识。因此，该活动需要人员具备足够高的资质。

为了组织和进行完整的测试，需要资质合格的人员，而且对流程中许多参与者的要求，比对普通测试人员的要求更高。

---

### 57. Понятие тестового случая и сценария.

示例中给出了从自动取款机（ATM）取款的场景。该场景包含4个测试用例。场景开始时，自动取款机处于可接收银行卡的就绪状态。当用户将银行卡插入自动取款机后，机器应进行读卡操作，若读卡成功，会提示输入个人识别码（PIN码），此时自动取款机状态变为等待输入PIN码状态。接下来，测试用例假设用户输入正确的PIN码，机器对PIN码进行验证，随后显示提供各类交易选项的界面。  

之后，用户选择所需操作，此处假定操作为取5000卢布。正确的测试场景要求用户账户中有足够余额，执行该测试用例的结果是自动取款机吐出相应金额的现金。吐钞完成后，自动取款机应回到可接收银行卡的初始就绪状态。  

需再次强调，示例中的每一行对应一个单独的测试用例。通过改变用户操作、创建针对不同信息输入的各类测试用例所形成的测试场景集合，应能为系统所需功能集构建必要的测试覆盖。  

在测试场景中，需同时考虑系统对用户操作的正向和负向反馈。对于用户的错误操作，也要创建相应测试场景。  

在上述示例中，测试场景会验证用户连续3次错误输入PIN码的情况。要对每一步错误输入PIN码的测试用例进行检验，以及在场景末尾检验银行卡最终被锁定的情况。执行完整个场景后，自动取款机应回到初始状态。  

**测试规划要点**

规划测试时，需在产品投入使用的质量和速度之间取得平衡。

测试用例越多，覆盖范围越大，质量往往也越高，但同时花费的时间和资源也会增加。

有可能出现这样的情况：竞争对手因测试更少、产品推出更快，占领了销售市场，即便你经过长时间测试的程序质量优于竞品，也会变得无人问津。

鉴于完全的测试覆盖无法实现，确定测试场景数量时，需借助一系列方法来界定足够的测试覆盖范围。

---

### 58. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.

能够确定充分测试覆盖范围的方法，其中最知名的是**等价类划分法**，有时也被称作等价区间划分法。在该方法框架内，还会进行边界值分析，在这些边界值范围内，被测功能的表现是一致的。  

另一种方法是**判定表法**（直译为“替代解决方案表法” ，更常用“判定表法”表述 ）。会编制一张表格，反映输入数据（和/或条件 ）的组合与相应输出数据（和/或操作/结果 ）的对应关系，需要针对这类组合组开展测试。  

还有一种基于**状态转移表**的方法，会识别出系统内部的明确状态，确定这些状态之间的转移，随后用测试覆盖这些转移。  

在确定系统使用需求期间编制的用户场景，可作为形成测试覆盖范围的数据来源。此时，要为每个描述的场景添加用户输入的具体数值。既要考虑场景的主流程，也要考虑替代流程（分支）。通常，每个这样的用户场景会对应一整组测试场景。  

进行等价性分析时，**被测功能或模块会被划分成不同区段**，程序在每个区段内的表现一致（等价）。在每个区段内会形成各自的测试用例集。如果这样的区段相对较少，就能大幅减少测试用例的数量。会为区段的边界值单独编制测试用例。  

>幻灯片中呈现了一个人吃冰淇淋的数量与满意度的关系。如果人还没吃冰淇淋，满意度为零。开始吃之后，满意度呈线性增长。达到饱和后，满意度的增长速度开始下降，超过某个特定点后，由于吃太多，满意度会急剧下降。  
显然，这个函数图像可以划分成几个区段，在图中用不同颜色的矩形表示。在每个区段内，函数的表现一致（更准确地说，我们可以认为函数表现一致）。基于此，我们可以在每个区段只选几个值来进行测试。  

图像上的点代表每个区段的边界。为形成测试覆盖，这些边界点必须单独测试。每个区间内的测试数量由分析人员确定，通常会根据合理的判断来选择。在这个例子中，3 - 5个点就足以形成测试覆盖。

---

### 59. Модульное тестирование. Junit 4.

##### V 模型测试阶段

经典 V 模型里，测试分阶段：**先模块测试，再集成测试，接着系统测试，最后验收测试** ，一步步验证应用。

##### 模块测试基础

模块是程序里独立功能组件，像 Java 里的方法、类，或是多个类/方法组成的程序单元，设计时由架构师拆分。

测试模块时要 **隔离** ，避免其他模块干扰。隔离靠 **驱动（Driver）** 调模块、 **桩（Stub）** 替代依赖模块，有时还要单独为模块做测试包。

##### 模块测试工具与方法

**驱动（Driver）**：驱动负责按顺序调模块，传不同参数/条件，控制测试流程。
**桩**模拟依赖模块，接口一样但实现简单，返回预设值，常用表格映射参数和返回值，直观好做。

##### JUnit（以 Java 为例）

Java 用 **JUnit** 做模块测试：
- **标记测试方法** ：`@Test` 注解标记测试方法，框架用反射找这些方法执行。 
- **断言（Assertion）** ：用断言函数（如判等、查异常）验证结果，结果记日志分析。
- **控制测试环境** ：`@Before`/`@After` 等注解，控制测试前后执行代码，准备/清理环境。
- **执行顺序** ：默认测试并行独立，也能手动指定顺序。

V 模型测试分阶段，模块测试要隔离，用驱动、桩模拟环境，Java 靠 JUnit 这类框架，用注解、断言高效测，核心是 **拆分功能、隔离干扰、自动验证**

---

### 60. Интеграционное тестирование. Стратегии интеграции. 集成测试。集成策略

组件**集成测试会在模块测试后**，检验程序组件（如库、框架等）之间的交互。从方法上看，它与系统集成测试非常相似，不过核心区别在于：**组件集成测试聚焦于单个程序组件的功能**，而**系统集成测试关注的是组件间交互是否符合既定需求、规范和标准**。组件集成测试通常在开发的早期阶段进行，旨在检查不同程序部分（组件）之间的交互情况。

系统集成测试则用于检验程序系统或系统架构各部分（开发的和购买的）之间的交互。在某些情况下，这种测试只能从一方（如客户或供应商）发起，且可能贯穿整个测试过程。现代业务流程可能涉及在不同站点（如数据中心）分别开发的软件不同部分的持续集成。剩下的组件集成工作可能要等两个组件都开发完成后才能进行。

集成测试的后续阶段包括对模块交互的验证，这由所开发软件的**战略集成**决定。选择具体的集成策略，取决于所开发软件的类型以及整体的软件开发计划。  

在制定软件开发计划时，有必要考虑未来的集成策略，以及模块开发的顺序和可能性，同时要兼顾复杂度、整体工作量和日程安排。  

以下是要考虑的集成策略：

##### 1. 自上而下

最常用，主要用于业务应用。流程：
- 先用驱动（Driver）和桩（Stub）验证**业务逻辑**；
- 再接入用户界面（UI），让 UI 向业务逻辑模块发真实请求；
- 最后接入数据存储模块（底层模块），完成模块测试与集成测试。

**优点**：能快速向客户演示应用。 
**缺点**：需开发大量桩，可能导致“测试专用”的冗余软件过多。

##### 2. 自下而上

多在“应用与硬件强关联”场景使用（如嵌入式系统）。流程：
- 从**最贴近硬件的底层模块**开始集成（因硬件开发周期长、更复杂）；
- 硬件原型就绪后，再测试依赖该硬件的其他模块。

**补充**：硬件厂商常提前提供测试版产品给合作方，避免拖慢整体进度。


##### 3. 按功能增量集成

按“功能”逐步扩展应用：
- 先完整实现并测试**第一个用户场景**（如“UI - 逻辑 - 数据库”流程）；
- 再依次叠加第二、第三个场景，直到应用完整。

##### 4. 核心先行集成(Ядро)

先构建**最小可用核心功能**，再逐步添加其他功能，持续扩展应用能力。

##### 5. 大爆炸集成(Большой взрыв)

最粗放的策略：**所有模块一次性集成**。若出现问题，难定位缺陷（因模块交互复杂），排障成本极高，仅适合非常简单的项目或早期快速验证。

简单总结：  
- 自上而下：先业务逻辑，再 UI、数据，快演示但桩多；
- 自下而上：从硬件相关模块开始，适配硬件开发周期；
- 功能增量：按用户场景逐个补齐，稳扎稳打；
- 核心先行：先保“能用”，再扩展；
- 大爆炸：全堆一起，出问题难修，慎用。  


---

### 61. Функциональное тестирование. Selenium.

功能测试通常被视为集成测试的一种形式。  

在功能测试中，会验证程序所具备的功能。这类测试基于**使用场景**开展，场景里会清晰描述用户在系统中的操作。需注意，一般会对完整的业务流程进行验证，流程中可能涉及不同用户角色依次执行业务流程的各个环节。  

功能测试的主要操作对象是**用户图形界面**。功能测试既可以由测试人员手动执行，也可借助与界面交互的自动化工具完成。此时，被测功能的开发需在应用的所有层级完全结束。  

遗憾的是，功能测试中无法完全避免手动测试。当已开发测试的成熟应用发生功能变更时，这点尤为明显。比如，一个用于录入和处理客户个人数据的应用，若要新增一个字段，之前开发的测试就会执行失败。测试人员通过手动测试发现该缺陷后，会提出修改测试的需求。  

针对功能测试，有大量自动化工具被开发出来，它们可接管用户界面的操作，包括键盘输入、指针移动、鼠标点击等。以下是这类工具的示例：  

- 基于使用场景  
- 手动/自动执行  
- 在成熟系统中，开展模块与集成测试环节的功能测试，从用户界面开始验证系统功能  

### 自动化工具  
- 开源工具：Selenium、Sahi、Watir 等  
- 商业工具：惠普（HP）、Rational（IBM 旗下）等产品  

其中，**Selenium** 是最常用的工具之一，它作为浏览器（如 Firefox）的扩展，能先录制界面操作的测试流程，再将其保存为测试程序，且可在其他浏览器中运行 。

---

### 62. Техники статического тестирования. Статический анализ кода.

静态测试（评审）是一种针对软件（包括代码）的测试类型，可在动态测试前开展。静态分析和动态测试的共同目标是发现缺陷，二者方法相互补充，因为它们发现不同类型缺陷的效率有所不同。与动态测试不同，静态方法找出的是故障原因（缺陷），而非故障本身（失效表现 ）。  

评审既可以手动进行，也能借助专门的软件工具开展。手动流程的核心环节是对软件产品进行研究与批注。  

**非正式同行评审**是一种常见技术，即请同事评估你代码或文档里的方案与算法。开发时，开发者容易因“熟视无睹”忽略明显问题，而同事有可能快速发现，但实际效果未必理想——同事可能因时间不足等因素给出主观、错误评价。  

IEEE 1028 - 2008 标准中定义了几种实用的正式静态测试技术，它们以有明确角色分工的会议形式开展：  
- **技术分析（重复审查法）**：由项目技术负责人主持会议。  
- **管理评审（management review）**：由开发经理主导。  
- **走查（walkthrough）**：由指定专家引领，带大家梳理工件（如需求文档、代码 ），记录并跟进问题修复。  
- **审查（由 IBM 迈克尔·费根提出）**：基于“人同时仅能有效关注两个参数”的理念，每位审查员承担两个角色，聚焦对应内容检查。  

评审可覆盖软件研发全流程产物，像需求/设计文档、代码、测试计划、测试用例、用户手册，甚至网页。  

在软件生命周期早期（如需求阶段）通过评审发现并修复缺陷，成本远低于测试或编码阶段。而且，评审能揪出动态测试很难发现的问题（比如需求遗漏 ）。  

##### 评审的优势  
- 提前发现、修复缺陷
- 提升开发效率
- 缩短开发周期
- 减少测试时间与成本
- 降低全生命周期成本
- 减少缺陷数量
- 改善团队沟通
- 实现团队内知识传递（带教学性质）

##### 更易通过评审发现的典型缺陷
- 偏离标准规范
- 需求/设计缺陷
- 可维护性不足
- 接口规范错误

##### 静态测试方法的流程（以技术分析为例 ）
1. **组织准备**：规划、筹备资源，培训审查人员。
2. **技术负责人规划**：确定要评审的工件（如代码、文档 ）。
3. **向参与者讲解流程**：明确评审怎么开展。
4. **工件预评审**：大家先自行研究，发现问题提交给技术负责人和作者。
5. **会议筹备**：技术负责人协调时间，安排会议。
6. **召开会议**：
   - 确定测试计划，评估产品当前状态。
   - 验证产品是否符合标准（如功能完整、实现正确、适配后续环节 ）。
   - 识别软件异常（缺陷 ）。
   - 制定后续开发行动清单。
   - 记录会议内容，规划后续审查。
7. **整改与跟进**：技术负责人确保问题都被处理。


##### 静态代码分析工具示例

- **C 语言**：Lint（构建语法树，检查未初始化变量、“fopen 后未 fclose”等问题 ）。
- **Java 语言**：FindBugs（检测代码逻辑漏洞、跨平台兼容性破坏等风险 ）。

这些工具通过解析代码结构，做严格形式化检查，提前拦截潜在问题。

---

### 63. Тестирование системы в целом. Системное тестирование. Тестирование производительности.

系统整体测试在集成完成后开展，用于验证宣称特性，包含以下环节：
1. **阶段划分**：系统测试（开发方内部）、α/β测试（用户在开发方管控下）、验收测试（用户自主环境，决定是否付款），各阶段方法相似，结果判定严格度有别。
2. **测试流程**：从简单到复杂场景，先测宣称功能（用功能测试场景，不涉系统崩溃用例），再验证多用户/多请求下稳定性、错误数据应对、兼容性（跨浏览器、第三方软件适配），最后做高负载测试，明确性能极限。
3. **性能测试（CARAT）**：
    - **Capacity（容量）**：验证非功能需求（如信息处理量），逐参数施压看系统表现。
    - **Accuracy（精度）**：聚焦数学计算精度，对实时/物理模拟系统关键。 
    - **Response Time（响应时间）**：用户请求响应时长，交互系统通常1 - 5秒（正常负载）。 
    - **Availability（可用性）**：用公式Availability = (MTBF - MTTR) / MTBF（MTBF为故障间隔时间，MTTR为恢复时间）衡量，0.99999意味着年停机约5分钟（需集群方案）。 
    - **Throughput（吞吐量）**：单位时间处理客户端请求数。 
4. **工具与负载**：有HP Load Runner、Apache JMeter等工具，可模拟静态/动态（如梯度增长）负载，支持多协议、远程/分布式施压（Java场景常用JMeter），还能记录响应时间、生成测试日志。 

---

### 64. Тестирование системы в целом. Альфа- и бета-тестирование.

系统整体测试在集成完成后启动，此阶段需验证软件宣称的各项特性。

系统整体测试包含以下部分：
- **系统测试**：通常由开发组织内部执行，不引入外部人员。
- **α测试与β测试**：由用户在开发方的管控下进行。
- **验收测试**：用户在自有环境中独立执行，开发方不参与管控，此阶段将决定是否向开发方支付报酬。

整体而言，系统测试各阶段的方法基本一致，区别仅在于对测试结果解读的严格程度。

通过α和β测试，开发人员能获得有助于完成开发的宝贵反馈。此外，由于测试并非由开发人员执行，测试者可能会采用开发人员未考虑到的非标准路径。其中，α测试在开发方的环境中进行，而β测试则在真实的用户环境中（但仍在开发方的管控下）开展。

部分软件（尤其是互联网和技术领域）以“永久测试版”状态发布，即通过多次更新和优化，始终不将其视为完全完成的产品。这种方式使开发流程更灵活，并能在软件生命周期的更早阶段实现发布。