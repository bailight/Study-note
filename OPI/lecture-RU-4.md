### Управление изменениями для программных продуктов

---
#### Управление изменениями в проекте ПО

##### Требования к определению и управлению изменениями
Изменения могут фиксировать историю изменений и позволять проводить аудит изменений. Каждое изменение имеет связанные свойства, такие как идентификатор, дата, владелец, описание и связанные журналы изменений. В проектах по разработке программного обеспечения управление изменениями имеет решающее значение, и этот процесс необходимо стандартизировать, чтобы обеспечить плавный ход проекта.

##### Процесс управления изменениями
- **Этап запроса и анализа**: заказчик отправляет запрос на изменение в связи с новыми функциональными требованиями или проблемами и формирует соответствующие документы. Менеджер проекта несет ответственность за анализ технической осуществимости, затрат и выгод изменения и регистрацию их в журнале изменений.
- **Фаза подтверждения**: после одобрения запроса на изменение проанализируйте его влияние на другие части системы и разработайте подробный план изменений, включая определение ресурсов, времени и операционных шагов. После внедрения изменений протестируйте их и обновите соответствующую документацию.
- **Этап проверки**: менеджер проекта проверяет изменения, чтобы убедиться в достижении ожидаемых результатов, затем закрывает изменения, чтобы завершить весь процесс управления изменениями.

>В экономической сфере основополагающим элементом управления изменениями (например, организационными изменениями) является адаптация к изменяющимся условиям ведения бизнеса.

【схема】
![alt text](image/change-programm.png)
>В левой части показаны действия участников процесса по формированию и изменению набора артефактов, используемых для реализации изменения. Справа показаны фактические артефакты, задействованные или созданные в процессе изменения. Следует отметить, что данная модель по сути эквивалентна двум диаграммам UML — диаграмме деятельности и диаграмме классов.
Клиенты могут запрашивать изменения в системе, если им требуются новые функции или возникают проблемы. Для каждого случая формируется артефакт запроса, связанный с математическим выражением: требование (требование к системе) или отчет о проблеме (отчет о проблеме или ошибке). Оба эти запроса называются запросами на изменение (в дальнейшем тексте используется сокращение CR) и генерируют артефакты, такие как записи журнала запросов на изменение.
Затем запрос на изменение передается менеджеру проекта. Руководители проектов выполняют ряд задач, наиболее важными из которых являются анализ технической осуществимости изменений, а также анализ затрат и выгод для пользователей. На этом этапе первый фактор сформирует документ или артефакт «Техническая осуществимость изменения», а второй фактор сформирует документ «Затраты и выгоды изменения». Все это зафиксировано в журнале изменений.
Затем запрос поступает в так называемую комиссию по изменениям, которая оценивает необходимость и экономическую эффективность изменения, решает любые связанные с этим проблемы и управляет статусом изменения в журнале запросов на изменение. Если запрос на изменение одобрен, он переходит на этап анализа и внедрения изменения; В противном случае запрос может быть отменен или приостановлен.
После принятия решения об изменении необходимо проанализировать его потенциальное влияние на другие части системы и возможные последствия для пользователей (Анализ влияния изменения). Важно отметить, что в сложных системах изменения в одной части системы почти всегда будут иметь последствия, вызывающие изменения в других частях, поэтому влияние изменений необходимо тщательно изучать.
Необходимо создать план внедрения изменений (Create Planning), который определяет ресурсы, время и последовательность действий, необходимых для внедрения изменений. Результаты этих двух видов деятельности создают артефакты «Анализ влияния изменений» и «План изменений».
Затем изменения передаются на реализацию. Роль, ответственная за реализацию изменения (разработчик изменений), создает объекты, которые в совокупности составляют реализацию изменения (элементы), например строки кода. Затем проводится тестирование, и изменения регистрируются в соответствующей документации. Если создается новая версия продукта, т. е. «релиз» или конфигурация, генерируются соответствующие артефакты — отчет об испытаниях, документация и релиз системы.
В конце процесса внесения изменений они передаются менеджеру проекта (а иногда и заказчику), проверяются (создается артефакт «проверки изменений») и официально подтверждаются.

---
#### Система контроля версий
Сама система контроля версий используется для управления изменениями в программном коде и поддержки одновременной работы нескольких человек над кодом, а также для контроля изменений файлов, создаваемых пользователями системы контроля версий (т. е. программистами).

Существует три основных типа систем контроля версий:
1. **Система контроля версий на основе файловой системы**: разработчики используют центральный сервер с публичными разрешениями на доступ к файлам. Этот тип системы контроля версий создает специальные файлы в текущем каталоге и позволяет хранить и переключать версии только в пределах одной файловой системы.
2. **Централизованная система контроля версий**: имеет единый репозиторий для хранения исходного кода проекта на сервере, доступ к которому осуществляется клиентами по определенному протоколу.
3. **Распределенная система управления версиями**: существует центральный репозиторий, из которого пользователи могут загружать данные в свои собственные локальные репозитории. После нескольких этапов локальной проверки данные снова загружаются в центральный репозиторий. Git — это распределенная система контроля версий.


При использовании системы контроля версий (VCS) основная проблема заключается в том, что нескольким разработчикам приходится редактировать одни и те же файлы одновременно. Хотя одновременное редактирование уже давно стало технически возможным, конфликты разрешений возникают, когда разработчики вносят противоречивые изменения в свои задачи.

##### Широко распространенное решение
1. Метод **Блокировка-Изменение-Разблокировка**: в этом методе, когда один пользователь работает с файлом, файл блокируется для других пользователей, и они не могут его изменять. **Это снижает производительность команды**, поскольку другим пользователям либо нечего делать, либо приходится переключаться на другие задачи по контролю версий, связанные с общей файловой системой.
>Такой подход типичен для систем контроля версий на основе файловой системы.
2. **Метод копирования-изменения-слияния**: в этом методе каждый пользователь копирует весь репозиторий на свой локальный компьютер, управляет им и изменяет его, а затем фиксирует изменения обратно в репозитории (хранилище). В этом случае **могут возникнуть конфликты при слиянии изменений**.

---
#### SVN (Subversion)
- **Архитектура и метод доступа**: централизованная система контроля версий, репозиторий хранится на сервере Berkeley DB или, в более простом случае, хранится в файловой системе (FSFS), доступ к которой можно получить через svnserve или Apache + mod_dav_svn, и поддерживает несколько протоколов передачи: протокол svn или svn + https, ssh + svn соединение.
- **Процесс использования и структура хранилища**: разработчики получают рабочие копии через оформление заказа, обновляют код с помощью обновления, управляют изменениями с помощью таких команд, как добавление и удаление, и, наконец, фиксируют изменения. Репозитории классифицируются по проектам, включая стволы, ветви и теги, что облегчает управление различными версиями проекта и этапами разработки. Клиент SVN также может выполнять контроль версий локальных наборов файлов. Например, когда определенная версия извлекается из репозитория, локальный набор файлов должен быть изменен в соответствии с содержимым выбранной версии.

В SVN каждый раз, когда вы отправляете изменения (svn commit) в репозиторий, версия проекта увеличивается на 1. Версия проекта всегда представляет собой целое число, которое уникально идентифицирует конкретную версию. В любое время, если фиксация прошла успешно, статус репозитория обновляется.

Каждый коммит (svn commit) должен содержать те файлы, изменения которых необходимо сохранить в репозитории. Если изменения были инициированы одной командной строкой, то эта командная строка должна охватывать все соответствующие файлы. В идеале коммит, например исправление ошибки, должен содержать только набор связанных изменений. **Не рекомендуется объединять разные изменения в один коммит. **

- Основной процесс разработки осуществляется в главном каталоге.
- Чтобы предоставить разные версии разным клиентам или опубликовать исторические версии проекта, разработчики могут скопировать содержимое каталога trunk в каталог branchs.
- В SVN при создании новой ветки все файлы исходной ветки копируются в новый каталог. На этом этапе версия репозитория также увеличивается.

**Тип отделения**:
- trunk - основная ветвь разработки.
- ветви - каталоги используются для хранения отдельных версий модификаций, особенно основных структурных версий продукта (например, 3.0 или 3.5). В филиалах вы также можете выполнять разработку независимых филиалов. Функции, реализуемые этими ветвями, не входят в основной набор функций. После сравнения с основной версией и проверки всех необходимых изменений эти реализации функций можно объединить в основную ветку.
- Ветка поставщика — здесь вы можете хранить версии, относящиеся к стороннему коду, используемому вашим проектом (например, версии сторонних библиотек).
> Чтобы отметить определенную версию проекта, используйте каталог тегов.

![альтернативный текст](image/svn-1.png)
Чтобы начать ежедневную работу, вам необходимо загрузить обновления с сервера в свою файловую систему, то есть обновить свою локальную копию.
svn update — приводит вашу рабочую копию в то же состояние, что и текущее состояние на сервере.
svn add (используется для создания (добавления) файлов)
svn delete (используется для удаления файлов)
svn copy и т. д. (также работает с каталогами и перемещением файлов между ветками)
И совершить

Если вам необходимо отменить изменения, вы можете воспользоваться командой svn revert.
А команды svn status и svn diff помогут понять, что изменилось по сравнению с сервером.
Возникают конфликты между изменениями разработчика и изменениями на сервере, которые можно разрешить с помощью таких команд, как svn diff и svn commit.

- **(e) edit**: используется для изменения файлов в редакторе.
- **(df) diff-full**: Отображение полного списка различий между ревизиями.
- **(r) разрешен**: используется для подтверждения того, что конфликт был разрешен в текущей (возможно, отредактированной) версии файла.
- **(dc) display-conflict** : Отобразить все конфликты.
- **(mc) mine-conflict, (tc) theirs-conflict**: используется для подтверждения того, что версия в вашей (локальной) версии или в репозитории является разрешением конфликта.
- **(mf) mine-full, (tf) theirs-full**: используется для полного подтверждения ваших собственных (локальных) или репозиторных версий файлов соответственно.
- **(p) отложить**: отложить разрешение конфликта на более позднее время.
- **(l) launch**: запуск внешнего инструмента.


![альтернативный текст](image/svn-2.png)
`svn update` используется для обновления локальной рабочей копии с сервера.
`U` означает, что файл был успешно обновлен (например, `Pokédex.xml`)
`G` указывает, что файл был успешно объединен (например, `Slowimperator.java`)
`Обнаружен конфликт в `Slowking.java`` указывает на то, что в файле `Slowking.java` обнаружен конфликт, и пользователю предлагается сделать выбор.

Объясняет три файла, которые задействуются при возникновении конфликта:
- **filename.mine**: локальная версия файла разработчика до выполнения `svn update`.
- **filename.rOLDREV**: версия файла в репозитории до возникновения конфликта.
- **filename.rNEWREV**: версия файла в текущем репозитории.

(p) Отсрочка обычно является предпочтительным вариантом при обнаружении конфликтов во время операции обновления SVN, поскольку часто бывает сложно разрешить конфликты независимо, и необходимо найти авторов конфликтующих изменений и договориться о решении. В то же время существуют некоторые инструменты (например, `triple diff`), которые могут легко сравнить эти три файла одновременно, чтобы помочь в разрешении конфликтов.

>При работе с параллельными ветками часто возникает необходимость объединить изменения из одной ветки с изменениями из другой ветки для формирования общей ветки. Для этой цели используется команда `svn merge`.
Возьмем в пример разработку нового трейлера к фильму.
В ревизии 9 содержимое /rokedex/trunk было скопировано в ветку /rokedex/branches/FR217-newmovies.
После этого разработка ведется в двух неконфликтующих ветках репозитория (коммиты `r11:r13`, `r15:r16` и `r18:r19`).
В версиях 14 и 17 изменения из основной ветки были объединены в ветку `FR217-newmovies`.
В версии 20 изменения из ветки `FR217-newmovies` были объединены с основной веткой.
**Типы конфликтов, возникающих в процессе слияния, можно разделить на текстовые конфликты и конфликты атрибутов. **

---
#### GIT
Распределенная система контроля версий, у каждого разработчика есть локальный репозиторий для облегчения совместной работы. Рабочий процесс включает клонирование проекта из удаленного репозитория, создание ветки, изменение кода, подготовку изменений, фиксацию в локальном репозитории и, наконец, отправку в удаленный репозиторий.

`clone` - может клонировать удаленный репозиторий в локальный репозиторий
`init` - может создать локальный репозиторий
`branch` - создает новую ветку (в этом процессе разработчик берет на себя роль владельца ветки, и ветка называется в его честь).

Чтобы привести рабочую копию в соответствие с состоянием нужной ветки (т. е. переключиться на эту ветку), можно использовать команду `checkout`. Создание ветки не мешает работе других разработчиков.

>Используйте команду `fetch` для извлечения данных с удаленного компьютера.Репозиторий получает изменения, но ваша рабочая копия автоматически не изменяется. Если вам необходимо объединить изменения, вы должны использовать команду `merge` (которая на самом деле является комбинацией нескольких команд). Не рекомендуется использовать команду `merge`, если в рабочей копии много изменений.

>Еще один способ объединить изменения из удаленного репозитория в вашу рабочую копию — использовать команду `fetch+rebase`, в этом случае изменения в вашей рабочей копии логически применяются к другому базовому коммиту.

Команда `fork` используется для создания ветви проекта в вашем собственном удаленном репозитории. Разработчики группируют изменения в собственном исходном репозитории и отправляют их в удаленный репозиторий с помощью команды запроса на извлечение.

Модель разработки git — различные изменения разрабатываются в отдельных ветках. Ветка `Master` хранит версию для пользователей, ветка `Develop` используется для основной разработки, а разработчики создают ветки `Feature` для требований и объединяют их в `Develop` после завершения. Когда накапливается достаточно функций, ветвь «Develop» преобразуется в ветвь «Release» для подготовки к выпуску. По завершении он копируется в «Master», а исправления ошибок синхронизируются с «Develop». Ветка «Hotfix» исправляет критические ошибки, а результаты передаются в ветку «Master» и в ветку «Develop». Процесс повторяется для новых требований.


**Управление ветвями и общие команды**
- **git status**: отображает текущее состояние файлов в файловой системе и информацию о редактируемой ветке.
- **git log**: отображает журнал коммитов. Добавление параметра --graph отображает ветви и их слияния в графическом виде.
- **git diff**: показывает все изменения, внесенные с момента последнего записанного изменения.
- **git reset --hard HEAD**: Отменить все изменения, внесенные в текущий локальный репозиторий.
- **git branch**: Отображение веток.
- **git checkout**: позволяет разработчикам переключаться между различными ветками.
- **git merge**: объединить несколько других веток в текущую ветку.
- **git commit**: зафиксировать изменения в текущей ветке. Параметр -m добавляет сообщение о фиксации, которое пользователи могут просмотреть.
- **git add**: Добавить измененные файлы к следующей отправке, то есть поместить их в область подготовки (Stage Area).

**плагин git flow**
Имеет функцию `init`, которая инициализирует репозиторий, упрощает первоначальную настройку, задает соответствующие вопросы и выполняет необходимую настройку.

- Создайте новую функцию `git flow feature start FEATURE_NAME`
- Завершите разработку функции и подготовьтесь к фиксации изменений `git flow feature finish FEATURE_NAME`

Остальные команды строятся аналогично. Это позволяет пользователям управлять версиями на более высоком, более абстрактном уровне, без необходимости точно знать, какие команды и порядок операций используются.

Для упрощения сложных инструкций в Git был разработан плагин Git Flow, который позволяет пользователям работать на уровне версий, а не на уровне операций, без необходимости понимать точный порядок команд и операций.

#### SVN против GIT

**SVN**
- **Project's Subversion repository | Репозиторий Subversion проекта**: это центральный репозиторий, в котором хранится вся информация о версиях проекта.
- **Working copy | Рабочая копия**: локальная копия, полученная разработчиком из центрального репозитория для разработки.
- **Стрелки и операции**:
- `commit`: зафиксировать изменения из рабочей копии в центральном репозитории.
- `checkout`: Извлечь проект из центрального репозитория в свою рабочую копию.
- `update`: обновить рабочую копию из центрального репозитория.
- `add`: Добавить новый файл в рабочую копию.
- `rm`: удалить файлы из рабочей копии.

**GIT**
- **Project's Git repository**: удаленный репозиторий проекта.
- **Your Git repository**: локальный репозиторий Git разработчика.
- **Working directory**: каталог, в котором выполняется фактическое редактирование кода и другая работа.
- **Index (область подготовки)**: используется для временного хранения изменений, которые необходимо отправить.
- **Стрелки и операции**:
- `push`: Передача изменений из локального репозитория в удаленный репозиторий проекта.
- `pull request`: отправить запрос на извлечение в удаленный репозиторий проекта.
- `fetch`: получение обновлений из удаленного репозитория проекта без слияния.
- `merge`: объединение ветвей или изменений.
- `checkout`: Извлечь файл или ветку в рабочий каталог.
- `commit`: Зафиксировать изменения в локальном репозитории.
- `add`: Добавить изменения в рабочем каталоге в область подготовки.
- `reset`: Сброс области подготовки или рабочего каталога.
- `clone`: Клонировать удаленный репозиторий в локальный.
- `fetch origin`: получить обновления из ветки `origin` удаленного репозитория.